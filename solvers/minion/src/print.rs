//! Functions to pretty print a model as a [Minion
//! file](https://minion-solver.readthedocs.io/en/latest/usage/input.html).

use std::io::Write;

use crate::ast::{Constant, Constraint, Model, Var, VarName};

/// Writes a complete Minion file for this model to `writer`.
pub fn write_minion_file(writer: &mut impl Write, model: &Model) -> Result<(), std::io::Error> {
    writeln!(writer, "# Autogenerated by minion_rs")?;
    writeln!(writer, "MINION 3")?;

    write_variables_section(writer, model)?;
    write_search_section(writer, model)?;
    write_constraints_section(writer, model)?;
    writeln!(writer, "**EOF**")
}

/// Writes the `VARIABLES` section of the Minion file to `writer`.
pub fn write_variables_section(
    writer: &mut impl Write,
    model: &Model,
) -> Result<(), std::io::Error> {
    writeln!(writer, "**VARIABLES**")?;

    let symtab = &model.named_variables;

    // print variables in declaration order
    for name in symtab.get_variable_order() {
        write_variable_declaration(writer, model, name)?;
    }
    Ok(())
}

/// Writes the `SEARCH` section of the Minion file to `writer`.
pub fn write_search_section(writer: &mut impl Write, model: &Model) -> Result<(), std::io::Error> {
    // TODO: print maximising and minimising once we get it

    let symtab = &model.named_variables;

    writeln!(writer, "**SEARCH**")?;

    // no aux vars
    let varorder = symtab.get_search_variable_order();

    writeln!(writer, "VARORDER STATIC [{}]", varorder.join(","))
}

/// Writes the `CONSTRAINTS` section of the Minion file to `writer`.
pub fn write_constraints_section(
    writer: &mut impl Write,
    model: &Model,
) -> Result<(), std::io::Error> {
    let constraints = &model.constraints;
    writeln!(writer, "**CONSTRAINTS**")?;

    for constraint in constraints {
        writeln!(writer, "{constraint}")?;
    }

    Ok(())
}

/// Writes the variable declaration of `name` to `writer`.
///
/// # Panics
///
/// If `name` does not exist.
pub fn write_variable_declaration(
    writer: &mut impl Write,
    model: &Model,
    name: VarName,
) -> Result<(), std::io::Error> {
    let symtab = &model.named_variables;

    #[allow(clippy::expect_used)]
    match symtab.get_vartype(name.clone()).expect("name should exist") {
        crate::ast::VarDomain::Bound(i, j) => writeln!(writer, "BOUND {name} {{{i}..{j}}}")?,
        crate::ast::VarDomain::Discrete(i, j) => writeln!(writer, "DISCRETE {name}, {{{i}..{j}}}")?,
        crate::ast::VarDomain::Bool => writeln!(writer, "BOOL {name}")?,
    };

    Ok(())
}

pub(crate) fn print_const_array(array: &[Constant]) -> String {
    let string_array: Vec<String> = array.iter().map(|x| format!("{x}")).collect();
    let string = string_array.join(",");
    format!("[{string}]")
}

pub(crate) fn print_var_array(array: &[Var]) -> String {
    let string_array: Vec<String> = array.iter().map(|x| format!("{x}")).collect();
    let string = string_array.join(",");
    format!("[{string}]")
}

pub(crate) fn print_constraint_array(array: &[Constraint]) -> String {
    let string_array: Vec<String> = array.iter().map(|x| format!("{x}")).collect();
    let string = string_array.join(",");
    format!("[{string}]")
}
