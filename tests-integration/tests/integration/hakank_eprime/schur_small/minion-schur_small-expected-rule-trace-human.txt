Model before rewriting:

letting n be 2
letting num_boxes be 3
find schur: matrix indexed by [[int(1..n)]] of int(1..num_boxes)

such that

and([ ((sum([i,j;int(1..)]) = k)) -> (!(and([(schur[i] = schur[j]),(schur[j] = schur[k]);int(1..)]))) | i : int(1..n), j : int(1..n), k : int(1..n) ])

--

and([ ((sum([i,j;int(1..)]) = k)) -> (!(and([(schur#matrix_to_atom[i] = schur#matrix_to_atom[j]),(schur#matrix_to_atom[j] = schur#matrix_to_atom[k]);int(1..)]))) | i : int(1..n), j : int(1..n), k : int(1..n) ]), 
   ~~> select_representation_matrix ([("Representations", 8001)]) 
and([ ((sum([i,j;int(1..)]) = k)) -> (!(and([(schur#matrix_to_atom[i] = schur#matrix_to_atom[j]),(schur#matrix_to_atom[j] = schur#matrix_to_atom[k]);int(1..)]))) | i : int(1..n), j : int(1..n), k : int(1..n) ]) 
new variables:
  find schur#matrix_to_atom_1: int(1..3)
  find schur#matrix_to_atom_2: int(1..3)
--

Model before rewriting:

find i: int(1..n)
find j: int(1..n)
find k: int(1..n)
find __0: bool
find __1: bool

such that

(true != ((sum([i,j;int(1..)]) = k)) -> (!(and([__0,__1;int(1..)]))))

--

!(and([__0,__1;int(1..)])), 
   ~~> distribute_not_over_and ([("Base", 8400)]) 
or([!(__0),!(__1);int(1..)]) 

--

(sum([i,j;int(1..)]) = k), 
   ~~> introduce_weighted_sumleq_sumgeq ([("Minion", 4600)]) 
and([SumLeq([i, j], k),SumGeq([i, j], k);int(1..)]) 

--

(true != (and([SumLeq([i, j], k),SumGeq([i, j], k);int(1..)])) -> (or([!(__0),!(__1);int(1..)]))), 
   ~~> flatten_generic ([("Minion", 4200)]) 
(true != __2) 
new variables:
  find __2: bool
new constraints:
  __2 =aux (and([SumLeq([i, j], k),SumGeq([i, j], k);int(1..)])) -> (or([!(__0),!(__1);int(1..)]))
--

__2 =aux (and([SumLeq([i, j], k),SumGeq([i, j], k);int(1..)])) -> (or([!(__0),!(__1);int(1..)])), 
   ~~> bool_eq_to_reify ([("Minion", 4400)]) 
Reify((and([SumLeq([i, j], k),SumGeq([i, j], k);int(1..)])) -> (or([!(__0),!(__1);int(1..)])), __2) 

--

(and([SumLeq([i, j], k),SumGeq([i, j], k);int(1..)])) -> (or([!(__0),!(__1);int(1..)])), 
   ~~> flatten_imply ([("Minion", 4200)]) 
(__3) -> (or([!(__0),!(__1);int(1..)])) 
new variables:
  find __3: bool
new constraints:
  __3 =aux and([SumLeq([i, j], k),SumGeq([i, j], k);int(1..)])
--

(__3) -> (or([!(__0),!(__1);int(1..)])), 
   ~~> introduce_reifyimply_ineq_from_imply ([("Minion", 4400)]) 
ReifyImply(or([!(__0),!(__1);int(1..)]), __3) 

--

__3 =aux and([SumLeq([i, j], k),SumGeq([i, j], k);int(1..)]), 
   ~~> bool_eq_to_reify ([("Minion", 4400)]) 
Reify(and([SumLeq([i, j], k),SumGeq([i, j], k);int(1..)]), __3) 

--

!(__0), 
   ~~> not_literal_to_wliteral ([("Minion", 4100)]) 
WatchedLiteral(__0,false) 

--

!(__1), 
   ~~> not_literal_to_wliteral ([("Minion", 4100)]) 
WatchedLiteral(__1,false) 

--

Final model:

find i: int(1..n)
find j: int(1..n)
find k: int(1..n)
find __0: bool
find __1: bool
find __2: bool
find __3: bool

such that

(true != __2),
Reify(ReifyImply(or([WatchedLiteral(__0,false),WatchedLiteral(__1,false);int(1..)]), __3), __2),
Reify(and([SumLeq([i, j], k),SumGeq([i, j], k);int(1..)]), __3)

Model before rewriting:

given i: int(1..n)
given j: int(1..n)
given k: int(1..n)

such that

((sum([i,j;int(1..)]) = k)) -> (!(and([(schur#matrix_to_atom[i] = schur#matrix_to_atom[j]),(schur#matrix_to_atom[j] = schur#matrix_to_atom[k]);int(1..)])))

--

!(and([(schur#matrix_to_atom[i] = schur#matrix_to_atom[j]),(schur#matrix_to_atom[j] = schur#matrix_to_atom[k]);int(1..)])), 
   ~~> distribute_not_over_and ([("Base", 8400)]) 
or([!((schur#matrix_to_atom[i] = schur#matrix_to_atom[j])),!((schur#matrix_to_atom[j] = schur#matrix_to_atom[k]));int(1..)]) 

--

schur#matrix_to_atom[i], 
   ~~> index_to_bubble ([("Bubble", 6000)]) 
{schur#matrix_to_atom[i] @ and([__inDomain(i,int(1..2));int(1..)])} 

--

((sum([i,j;int(1..)]) = k)) -> (or([!(({schur#matrix_to_atom[i] @ and([__inDomain(i,int(1..2));int(1..)])} = schur#matrix_to_atom[j])),!((schur#matrix_to_atom[j] = schur#matrix_to_atom[k]));int(1..)])), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
((sum([i,j;int(1..)]) = k)) -> (or([!((schur#matrix_to_atom[i] = schur#matrix_to_atom[j])),!((schur#matrix_to_atom[j] = schur#matrix_to_atom[k]));int(1..)])) 

--

schur#matrix_to_atom[j], 
   ~~> index_to_bubble ([("Bubble", 6000)]) 
{schur#matrix_to_atom[j] @ and([__inDomain(j,int(1..2));int(1..)])} 

--

((sum([i,j;int(1..)]) = k)) -> (or([!((schur#matrix_to_atom[i] = {schur#matrix_to_atom[j] @ and([__inDomain(j,int(1..2));int(1..)])})),!((schur#matrix_to_atom[j] = schur#matrix_to_atom[k]));int(1..)])), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
((sum([i,j;int(1..)]) = k)) -> (or([!((schur#matrix_to_atom[i] = schur#matrix_to_atom[j])),!((schur#matrix_to_atom[j] = schur#matrix_to_atom[k]));int(1..)])) 

--

!((schur#matrix_to_atom[i] = schur#matrix_to_atom[j])), 
   ~~> negated_eq_to_neq ([("Base", 8800)]) 
(schur#matrix_to_atom[i] != schur#matrix_to_atom[j]) 

--

schur#matrix_to_atom[j], 
   ~~> index_to_bubble ([("Bubble", 6000)]) 
{schur#matrix_to_atom[j] @ and([__inDomain(j,int(1..2));int(1..)])} 

--

((sum([i,j;int(1..)]) = k)) -> (or([(schur#matrix_to_atom[i] != schur#matrix_to_atom[j]),!(({schur#matrix_to_atom[j] @ and([__inDomain(j,int(1..2));int(1..)])} = schur#matrix_to_atom[k]));int(1..)])), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
((sum([i,j;int(1..)]) = k)) -> (or([(schur#matrix_to_atom[i] != schur#matrix_to_atom[j]),!((schur#matrix_to_atom[j] = schur#matrix_to_atom[k]));int(1..)])) 

--

schur#matrix_to_atom[k], 
   ~~> index_to_bubble ([("Bubble", 6000)]) 
{schur#matrix_to_atom[k] @ and([__inDomain(k,int(1..2));int(1..)])} 

--

((sum([i,j;int(1..)]) = k)) -> (or([(schur#matrix_to_atom[i] != schur#matrix_to_atom[j]),!((schur#matrix_to_atom[j] = {schur#matrix_to_atom[k] @ and([__inDomain(k,int(1..2));int(1..)])}));int(1..)])), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
((sum([i,j;int(1..)]) = k)) -> (or([(schur#matrix_to_atom[i] != schur#matrix_to_atom[j]),!((schur#matrix_to_atom[j] = schur#matrix_to_atom[k]));int(1..)])) 

--

!((schur#matrix_to_atom[j] = schur#matrix_to_atom[k])), 
   ~~> negated_eq_to_neq ([("Base", 8800)]) 
(schur#matrix_to_atom[j] != schur#matrix_to_atom[k]) 

--

(sum([i,j;int(1..)]) = k), 
   ~~> introduce_weighted_sumleq_sumgeq ([("Minion", 4600)]) 
and([SumLeq([i, j], k),SumGeq([i, j], k);int(1..)]) 

--

Final model:

given i: int(1..n)
given j: int(1..n)
given k: int(1..n)

such that

(and([SumLeq([i, j], k),SumGeq([i, j], k);int(1..)])) -> (or([(schur#matrix_to_atom[i] != schur#matrix_to_atom[j]),(schur#matrix_to_atom[j] != schur#matrix_to_atom[k]);int(1..)]))

and([ ((sum([i,j;int(1..)]) = k)) -> (!(and([(schur#matrix_to_atom[i] = schur#matrix_to_atom[j]),(schur#matrix_to_atom[j] = schur#matrix_to_atom[k]);int(1..)]))) | i : int(1..n), j : int(1..n), k : int(1..n) ]), 
   ~~> expand_comprehension_ac ([("Better_AC_Comprehension_Expansion", 2001)]) 
and([(and([SumLeq([1, 1], 2),SumGeq([1, 1], 2);int(1..)])) -> (or([(schur#matrix_to_atom[1] != schur#matrix_to_atom[1]),(schur#matrix_to_atom[1] != schur#matrix_to_atom[2]);int(1..)]));int(1..)]) 

--

and([(and([SumLeq([1, 1], 2),SumGeq([1, 1], 2);int(1..)])) -> (or([(schur#matrix_to_atom[1] != schur#matrix_to_atom[1]),(schur#matrix_to_atom[1] != schur#matrix_to_atom[2]);int(1..)]));int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
or([(schur#matrix_to_atom[1] != schur#matrix_to_atom[1]),(schur#matrix_to_atom[1] != schur#matrix_to_atom[2]);int(1..)]) 

--

or([(schur#matrix_to_atom[1] != schur#matrix_to_atom[1]),(schur#matrix_to_atom[1] != schur#matrix_to_atom[2]);int(1..)]), 
   ~~> index_matrix_to_atom ([("Base", 5000)]) 
or([(schur#matrix_to_atom_1 != schur#matrix_to_atom_1),(schur#matrix_to_atom_1 != schur#matrix_to_atom_2);int(1..)]) 

--

Final model:

letting n be 2
letting num_boxes be 3
find schur: matrix indexed by [[int(1..n)]] of int(1..num_boxes)
find schur#matrix_to_atom_1: int(1..3)
find schur#matrix_to_atom_2: int(1..3)

such that

or([(schur#matrix_to_atom_1 != schur#matrix_to_atom_1),(schur#matrix_to_atom_1 != schur#matrix_to_atom_2);int(1..)])

