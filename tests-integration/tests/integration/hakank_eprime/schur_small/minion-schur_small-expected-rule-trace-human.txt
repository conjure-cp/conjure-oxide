Model before rewriting:

letting n be 2
letting num_boxes be 3
find schur: matrix indexed by [[int(1..n)]] of int(1..num_boxes)

such that

and([ ((sum([i,j;int(1..)]) = k)) -> (!(and([(schur[i] = schur[j]),(schur[j] = schur[k]);int(1..)]))) | i : int(1..n), j : int(1..n), k : int(1..n) ])

--

and([ ((sum([i,j;int(1..)]) = k)) -> (!(and([(schur#matrix_to_atom[i] = schur#matrix_to_atom[j]),(schur#matrix_to_atom[j] = schur#matrix_to_atom[k]);int(1..)]))) | i : int(1..n), j : int(1..n), k : int(1..n) ]), 
   ~~> select_representation_matrix ([("Representations", 8001)]) 
and([ ((sum([i,j;int(1..)]) = k)) -> (!(and([(schur#matrix_to_atom[i] = schur#matrix_to_atom[j]),(schur#matrix_to_atom[j] = schur#matrix_to_atom[k]);int(1..)]))) | i : int(1..n), j : int(1..n), k : int(1..n) ]) 
new variables:
  find schur#matrix_to_atom_1: int(1..3)
  find schur#matrix_to_atom_2: int(1..3)
--

[ ((sum([i,j;int(1..)]) = k)) -> (!(and([(schur#matrix_to_atom[i] = schur#matrix_to_atom[j]),(schur#matrix_to_atom[j] = schur#matrix_to_atom[k]);int(1..)]))) | i : int(1..n), j : int(1..n), k : int(1..n) ], 
   ~~> expand_comprehension ([("Base", 2000)]) 
[true,!(and([(schur#matrix_to_atom[1] = schur#matrix_to_atom[1]),(schur#matrix_to_atom[1] = schur#matrix_to_atom[2]);int(1..)])),true,true,true,true,true,true;int(1..)] 

--

and([true,!(and([(schur#matrix_to_atom[1] = schur#matrix_to_atom[1]),(schur#matrix_to_atom[1] = schur#matrix_to_atom[2]);int(1..)])),true,true,true,true,true,true;int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
!(and([(schur#matrix_to_atom[1] = schur#matrix_to_atom[1]),(schur#matrix_to_atom[1] = schur#matrix_to_atom[2]);int(1..)])) 

--

!(and([(schur#matrix_to_atom[1] = schur#matrix_to_atom[1]),(schur#matrix_to_atom[1] = schur#matrix_to_atom[2]);int(1..)])), 
   ~~> distribute_not_over_and ([("Base", 8400)]) 
or([!((schur#matrix_to_atom[1] = schur#matrix_to_atom[1])),!((schur#matrix_to_atom[1] = schur#matrix_to_atom[2]));int(1..)]) 

--

schur#matrix_to_atom[1], 
   ~~> index_to_bubble ([("Bubble", 6000)]) 
{schur#matrix_to_atom[1] @ and([__inDomain(1,int(1..2));int(1..)])} 

--

or([!(({schur#matrix_to_atom[1] @ and([__inDomain(1,int(1..2));int(1..)])} = schur#matrix_to_atom[1])),!((schur#matrix_to_atom[1] = schur#matrix_to_atom[2]));int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
or([!((schur#matrix_to_atom[1] = schur#matrix_to_atom[1])),!((schur#matrix_to_atom[1] = schur#matrix_to_atom[2]));int(1..)]) 

--

schur#matrix_to_atom[1], 
   ~~> index_to_bubble ([("Bubble", 6000)]) 
{schur#matrix_to_atom[1] @ and([__inDomain(1,int(1..2));int(1..)])} 

--

or([!((schur#matrix_to_atom[1] = {schur#matrix_to_atom[1] @ and([__inDomain(1,int(1..2));int(1..)])})),!((schur#matrix_to_atom[1] = schur#matrix_to_atom[2]));int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
or([!((schur#matrix_to_atom[1] = schur#matrix_to_atom[1])),!((schur#matrix_to_atom[1] = schur#matrix_to_atom[2]));int(1..)]) 

--

!((schur#matrix_to_atom[1] = schur#matrix_to_atom[1])), 
   ~~> negated_eq_to_neq ([("Base", 8800)]) 
(schur#matrix_to_atom[1] != schur#matrix_to_atom[1]) 

--

schur#matrix_to_atom[1], 
   ~~> index_to_bubble ([("Bubble", 6000)]) 
{schur#matrix_to_atom[1] @ and([__inDomain(1,int(1..2));int(1..)])} 

--

or([(schur#matrix_to_atom[1] != schur#matrix_to_atom[1]),!(({schur#matrix_to_atom[1] @ and([__inDomain(1,int(1..2));int(1..)])} = schur#matrix_to_atom[2]));int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
or([(schur#matrix_to_atom[1] != schur#matrix_to_atom[1]),!((schur#matrix_to_atom[1] = schur#matrix_to_atom[2]));int(1..)]) 

--

schur#matrix_to_atom[2], 
   ~~> index_to_bubble ([("Bubble", 6000)]) 
{schur#matrix_to_atom[2] @ and([__inDomain(2,int(1..2));int(1..)])} 

--

or([(schur#matrix_to_atom[1] != schur#matrix_to_atom[1]),!((schur#matrix_to_atom[1] = {schur#matrix_to_atom[2] @ and([__inDomain(2,int(1..2));int(1..)])}));int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
or([(schur#matrix_to_atom[1] != schur#matrix_to_atom[1]),!((schur#matrix_to_atom[1] = schur#matrix_to_atom[2]));int(1..)]) 

--

!((schur#matrix_to_atom[1] = schur#matrix_to_atom[2])), 
   ~~> negated_eq_to_neq ([("Base", 8800)]) 
(schur#matrix_to_atom[1] != schur#matrix_to_atom[2]) 

--

or([(schur#matrix_to_atom[1] != schur#matrix_to_atom[1]),(schur#matrix_to_atom[1] != schur#matrix_to_atom[2]);int(1..)]), 
   ~~> index_matrix_to_atom ([("Base", 5000)]) 
or([(schur#matrix_to_atom_1 != schur#matrix_to_atom_1),(schur#matrix_to_atom_1 != schur#matrix_to_atom_2);int(1..)]) 

--

Final model:

letting n be 2
letting num_boxes be 3
find schur: matrix indexed by [[int(1..n)]] of int(1..num_boxes)
find schur#matrix_to_atom_1: int(1..3)
find schur#matrix_to_atom_2: int(1..3)

such that

or([(schur#matrix_to_atom_1 != schur#matrix_to_atom_1),(schur#matrix_to_atom_1 != schur#matrix_to_atom_2);int(1..)])

