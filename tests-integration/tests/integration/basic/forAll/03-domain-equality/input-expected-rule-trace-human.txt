Model before rewriting:

find y: bool

such that

(y = and([given j: int(0..3)

such that

(product([j,j;int(1..)]) >= j)
 | j: int(0..3),]))

--

(y = and([given j: int(0..3)

such that

(product([j,j;int(1..)]) >= j)
 | j: int(0..3),])), 
   ~~> bool_eq_to_reify ([("Minion", 4400)]) 
Reify(and([given j: int(0..3)

such that

(product([j,j;int(1..)]) >= j)
 | j: int(0..3),]), y) 

--

Model before rewriting:

find j: int(0..3)

such that

(true != (product([j,j;int(1..)]) >= j))

--

(true != (product([j,j;int(1..)]) >= j)), 
   ~~> flatten_generic ([("Minion", 4200)]) 
(true != __0) 
new variables:
  find __0: bool
new constraints:
  __0 =aux (product([j,j;int(1..)]) >= j)
--

__0 =aux (product([j,j;int(1..)]) >= j), 
   ~~> bool_eq_to_reify ([("Minion", 4400)]) 
Reify((product([j,j;int(1..)]) >= j), __0) 

--

(product([j,j;int(1..)]) >= j), 
   ~~> flatten_generic ([("Minion", 4200)]) 
(__1 >= j) 
new variables:
  find __1: int(0..9)
new constraints:
  __1 =aux product([j,j;int(1..)])
--

__1 =aux product([j,j;int(1..)]), 
   ~~> introduce_producteq ([("Minion", 4200)]) 
FlatProductEq(j,j,__1) 

--

(__1 >= j), 
   ~~> geq_to_ineq ([("Minion", 4100)]) 
Ineq(j, __1, 0) 

--

Final model:

find j: int(0..3)
find __0: bool
find __1: int(0..9)

such that

(true != __0),
Reify(Ineq(j, __1, 0), __0),
FlatProductEq(j,j,__1)

Model before rewriting:

given j: int(0..3)

such that

(product([j,j;int(1..)]) >= j)

--

Final model:

given j: int(0..3)

such that

(product([j,j;int(1..)]) >= j)

and([given j: int(0..3)

such that

(product([j,j;int(1..)]) >= j)
 | j: int(0..3),__0: bool,__1: int(0..9),]), 
   ~~> expand_comprehension_ac ([("Better_AC_Comprehension_Expansion", 2001)]) 
and([;int(1..)]) 

--

Reify(and([;int(1..)]), y), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
Reify(true, y) 

--

Final model:

find y: bool

such that

Reify(true, y)

