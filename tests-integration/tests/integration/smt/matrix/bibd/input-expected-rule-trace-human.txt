Model before rewriting:

letting b be UnsafeDiv(product([product([l,v;int(1..)]),(v - 1);int(1..)]), product([k,(k - 1);int(1..)]))
find bibd: matrix indexed by [[int(1..3), int(1..3)]] of int(0..1)
letting k be 2
letting l be 1
letting r be UnsafeDiv(product([l,(v - 1);int(1..)]), (k - 1))
letting v be 3

such that

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
and([given row: int(1..2)

such that

(bibd[row,..] <=lex bibd[sum([row,1;int(1..)]),..])
 | row: int(1..2),]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),])

--

Model before rewriting:

find row: int(1..2)
find __0: bool

such that

(true != __0)

--

Final model:

find row: int(1..2)
find __0: bool

such that

(true != __0)

Model before rewriting:

given row: int(1..2)

such that

(bibd[row,..] <=lex bibd[sum([row,1;int(1..)]),..])

--

bibd[row,..], 
   ~~> slice_to_bubble ([("Bubble", 6000)]) 
{bibd[row,..] @ and([__inDomain(row,int(1..3));int(1..)])} 

--

({bibd[row,..] @ and([__inDomain(row,int(1..3));int(1..)])} <=lex bibd[sum([row,1;int(1..)]),..]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(bibd[row,..] <=lex bibd[sum([row,1;int(1..)]),..]) 

--

bibd[sum([row,1;int(1..)]),..], 
   ~~> slice_to_bubble ([("Bubble", 6000)]) 
{bibd[sum([row,1;int(1..)]),..] @ and([__inDomain(sum([row,1;int(1..)]),int(1..3));int(1..)])} 

--

(bibd[row,..] <=lex {bibd[sum([row,1;int(1..)]),..] @ and([__inDomain(sum([row,1;int(1..)]),int(1..3));int(1..)])}), 
   ~~> bubble_up ([("Bubble", 8800)]) 
{(bibd[row,..] <=lex bibd[sum([row,1;int(1..)]),..]) @ and([__inDomain(sum([row,1;int(1..)]),int(1..3));int(1..)])} 

--

{(bibd[row,..] <=lex bibd[sum([row,1;int(1..)]),..]) @ and([__inDomain(sum([row,1;int(1..)]),int(1..3));int(1..)])}, 
   ~~> expand_bubble ([("Bubble", 8900)]) 
and([(bibd[row,..] <=lex bibd[sum([row,1;int(1..)]),..]),and([__inDomain(sum([row,1;int(1..)]),int(1..3));int(1..)]);int(1..)]) 

--

and([(bibd[row,..] <=lex bibd[sum([row,1;int(1..)]),..]),and([__inDomain(sum([row,1;int(1..)]),int(1..3));int(1..)]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(bibd[row,..] <=lex bibd[sum([row,1;int(1..)]),..]),
and([__inDomain(sum([row,1;int(1..)]),int(1..3));int(1..)]) 

--

(bibd[row,..] <=lex bibd[sum([row,1;int(1..)]),..]),
and([__inDomain(sum([row,1;int(1..)]),int(1..3));int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(bibd[row,..] <=lex bibd[sum([row,1;int(1..)]),..]),
__inDomain(sum([row,1;int(1..)]),int(1..3)) 

--

Final model:

given row: int(1..2)

such that

(bibd[row,..] <=lex bibd[sum([row,1;int(1..)]),..]),
__inDomain(sum([row,1;int(1..)]),int(1..3))

and([given row: int(1..2)

such that

(bibd[row,..] <=lex bibd[sum([row,1;int(1..)]),..])
 | row: int(1..2),__0: bool,]), 
   ~~> expand_comprehension_ac ([("Better_AC_Comprehension_Expansion", 2001)]) 
and([and([(bibd[1,..] <=lex bibd[sum([1,1;int(1..)]),..]),__inDomain(sum([1,1;int(1..)]),int(1..3));int(1..)]),and([(bibd[2,..] <=lex bibd[sum([2,1;int(1..)]),..]),__inDomain(sum([2,1;int(1..)]),int(1..3));int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
and([and([(bibd[1,..] <=lex bibd[sum([1,1;int(1..)]),..]),__inDomain(sum([1,1;int(1..)]),int(1..3));int(1..)]),and([(bibd[2,..] <=lex bibd[sum([2,1;int(1..)]),..]),__inDomain(sum([2,1;int(1..)]),int(1..3));int(1..)]);int(1..)]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
and([(bibd[1,..] <=lex bibd[2,..]);int(1..)]),
and([(bibd[2,..] <=lex bibd[3,..]);int(1..)]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
and([(bibd[1,..] <=lex bibd[2,..]);int(1..)]),
and([(bibd[2,..] <=lex bibd[3,..]);int(1..)]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
(bibd[1,..] <=lex bibd[2,..]),
(bibd[2,..] <=lex bibd[3,..]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]) 

--

(bibd[1,..] <=lex bibd[2,..]), 
   ~~> expand_lex_lt_leq ([("Smt", 2001)]) 
or([(bibd[1, 1] < bibd[2, 1]),and([(bibd[1, 1] = bibd[2, 1]),or([(bibd[1, 2] < bibd[2, 2]),and([(bibd[1, 2] = bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),and([(bibd[1, 3] = bibd[2, 3]),true;int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),and([(bibd[1, 1] = bibd[2, 1]),or([(bibd[1, 2] < bibd[2, 2]),and([(bibd[1, 2] = bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),and([(bibd[1, 3] = bibd[2, 3]),true;int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]),
(bibd[2,..] <=lex bibd[3,..]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),and([(bibd[1, 1] = bibd[2, 1]),or([(bibd[1, 2] < bibd[2, 2]),and([(bibd[1, 2] = bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),and([(bibd[1, 3] = bibd[2, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]),
(bibd[2,..] <=lex bibd[3,..]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]) 

--

and([(bibd[1, 3] = bibd[2, 3]);int(1..)]), 
   ~~> remove_unit_vector_and ([("Base", 8800)]) 
(bibd[1, 3] = bibd[2, 3]) 

--

or([(bibd[1, 1] < bibd[2, 1]),and([(bibd[1, 1] = bibd[2, 1]),or([(bibd[1, 2] < bibd[2, 2]),and([(bibd[1, 2] = bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> distribute_or_over_and ([("Base", 8400)]) 
and([or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),or([(bibd[1, 1] < bibd[2, 1]),or([(bibd[1, 2] < bibd[2, 2]),and([(bibd[1, 2] = bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
and([or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),or([(bibd[1, 1] < bibd[2, 1]),or([(bibd[1, 2] < bibd[2, 2]),and([(bibd[1, 2] = bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]),
(bibd[2,..] <=lex bibd[3,..]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),or([(bibd[1, 2] < bibd[2, 2]),and([(bibd[1, 2] = bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]),
(bibd[2,..] <=lex bibd[3,..]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]) 

--

or([(bibd[1, 1] < bibd[2, 1]),or([(bibd[1, 2] < bibd[2, 2]),and([(bibd[1, 2] = bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> normalise_associative_commutative ([("Base", 8900)]) 
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),and([(bibd[1, 2] = bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]);int(1..)]);int(1..)]) 

--

or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),and([(bibd[1, 2] = bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> distribute_or_over_and ([("Base", 8400)]) 
and([or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]);int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
and([or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]);int(1..)]);int(1..)]),
(bibd[2,..] <=lex bibd[3,..]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]);int(1..)]),
(bibd[2,..] <=lex bibd[3,..]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]) 

--

or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),or([(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]);int(1..)]), 
   ~~> normalise_associative_commutative ([("Base", 8900)]) 
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]) 

--

(bibd[2,..] <=lex bibd[3,..]), 
   ~~> expand_lex_lt_leq ([("Smt", 2001)]) 
or([(bibd[2, 1] < bibd[3, 1]),and([(bibd[2, 1] = bibd[3, 1]),or([(bibd[2, 2] < bibd[3, 2]),and([(bibd[2, 2] = bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),and([(bibd[2, 3] = bibd[3, 3]),true;int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),and([(bibd[2, 1] = bibd[3, 1]),or([(bibd[2, 2] < bibd[3, 2]),and([(bibd[2, 2] = bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),and([(bibd[2, 3] = bibd[3, 3]),true;int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),and([(bibd[2, 1] = bibd[3, 1]),or([(bibd[2, 2] < bibd[3, 2]),and([(bibd[2, 2] = bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),and([(bibd[2, 3] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]) 

--

and([(bibd[2, 3] = bibd[3, 3]);int(1..)]), 
   ~~> remove_unit_vector_and ([("Base", 8800)]) 
(bibd[2, 3] = bibd[3, 3]) 

--

or([(bibd[2, 1] < bibd[3, 1]),and([(bibd[2, 1] = bibd[3, 1]),or([(bibd[2, 2] < bibd[3, 2]),and([(bibd[2, 2] = bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> distribute_or_over_and ([("Base", 8400)]) 
and([or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),or([(bibd[2, 1] < bibd[3, 1]),or([(bibd[2, 2] < bibd[3, 2]),and([(bibd[2, 2] = bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
and([or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),or([(bibd[2, 1] < bibd[3, 1]),or([(bibd[2, 2] < bibd[3, 2]),and([(bibd[2, 2] = bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),or([(bibd[2, 2] < bibd[3, 2]),and([(bibd[2, 2] = bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]) 

--

or([(bibd[2, 1] < bibd[3, 1]),or([(bibd[2, 2] < bibd[3, 2]),and([(bibd[2, 2] = bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> normalise_associative_commutative ([("Base", 8900)]) 
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),and([(bibd[2, 2] = bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]) 

--

or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),and([(bibd[2, 2] = bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> distribute_or_over_and ([("Base", 8400)]) 
and([or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
and([or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]);int(1..)]),
and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),]) 

--

or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),or([(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]);int(1..)]), 
   ~~> normalise_associative_commutative ([("Base", 8900)]) 
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]) 

--

Model before rewriting:

find col: int(1..2)
find __0: bool

such that

(true != __0)

--

Final model:

find col: int(1..2)
find __0: bool

such that

(true != __0)

Model before rewriting:

given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])

--

bibd[..,col], 
   ~~> slice_to_bubble ([("Bubble", 6000)]) 
{bibd[..,col] @ and([__inDomain(col,int(1..3));int(1..)])} 

--

({bibd[..,col] @ and([__inDomain(col,int(1..3));int(1..)])} <=lex bibd[..,sum([col,1;int(1..)])]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])]) 

--

bibd[..,sum([col,1;int(1..)])], 
   ~~> slice_to_bubble ([("Bubble", 6000)]) 
{bibd[..,sum([col,1;int(1..)])] @ and([__inDomain(sum([col,1;int(1..)]),int(1..3));int(1..)])} 

--

(bibd[..,col] <=lex {bibd[..,sum([col,1;int(1..)])] @ and([__inDomain(sum([col,1;int(1..)]),int(1..3));int(1..)])}), 
   ~~> bubble_up ([("Bubble", 8800)]) 
{(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])]) @ and([__inDomain(sum([col,1;int(1..)]),int(1..3));int(1..)])} 

--

{(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])]) @ and([__inDomain(sum([col,1;int(1..)]),int(1..3));int(1..)])}, 
   ~~> expand_bubble ([("Bubble", 8900)]) 
and([(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])]),and([__inDomain(sum([col,1;int(1..)]),int(1..3));int(1..)]);int(1..)]) 

--

and([(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])]),and([__inDomain(sum([col,1;int(1..)]),int(1..3));int(1..)]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])]),
and([__inDomain(sum([col,1;int(1..)]),int(1..3));int(1..)]) 

--

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])]),
and([__inDomain(sum([col,1;int(1..)]),int(1..3));int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])]),
__inDomain(sum([col,1;int(1..)]),int(1..3)) 

--

Final model:

given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])]),
__inDomain(sum([col,1;int(1..)]),int(1..3))

and([given col: int(1..2)

such that

(bibd[..,col] <=lex bibd[..,sum([col,1;int(1..)])])
 | col: int(1..2),__0: bool,]), 
   ~~> expand_comprehension_ac ([("Better_AC_Comprehension_Expansion", 2001)]) 
and([and([(bibd[..,1] <=lex bibd[..,sum([1,1;int(1..)])]),__inDomain(sum([1,1;int(1..)]),int(1..3));int(1..)]),and([(bibd[..,2] <=lex bibd[..,sum([2,1;int(1..)])]),__inDomain(sum([2,1;int(1..)]),int(1..3));int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
and([and([(bibd[..,1] <=lex bibd[..,sum([1,1;int(1..)])]),__inDomain(sum([1,1;int(1..)]),int(1..3));int(1..)]),and([(bibd[..,2] <=lex bibd[..,sum([2,1;int(1..)])]),__inDomain(sum([2,1;int(1..)]),int(1..3));int(1..)]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
and([(bibd[..,1] <=lex bibd[..,2]);int(1..)]),
and([(bibd[..,2] <=lex bibd[..,3]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
and([(bibd[..,1] <=lex bibd[..,2]);int(1..)]),
and([(bibd[..,2] <=lex bibd[..,3]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
(bibd[..,1] <=lex bibd[..,2]),
(bibd[..,2] <=lex bibd[..,3]) 

--

(bibd[..,1] <=lex bibd[..,2]), 
   ~~> expand_lex_lt_leq ([("Smt", 2001)]) 
or([(bibd[1, 1] < bibd[1, 2]),and([(bibd[1, 1] = bibd[1, 2]),or([(bibd[2, 1] < bibd[2, 2]),and([(bibd[2, 1] = bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),and([(bibd[3, 1] = bibd[3, 2]),true;int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),and([(bibd[1, 1] = bibd[1, 2]),or([(bibd[2, 1] < bibd[2, 2]),and([(bibd[2, 1] = bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),and([(bibd[3, 1] = bibd[3, 2]),true;int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]),
(bibd[..,2] <=lex bibd[..,3]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),and([(bibd[1, 1] = bibd[1, 2]),or([(bibd[2, 1] < bibd[2, 2]),and([(bibd[2, 1] = bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),and([(bibd[3, 1] = bibd[3, 2]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]),
(bibd[..,2] <=lex bibd[..,3]) 

--

and([(bibd[3, 1] = bibd[3, 2]);int(1..)]), 
   ~~> remove_unit_vector_and ([("Base", 8800)]) 
(bibd[3, 1] = bibd[3, 2]) 

--

or([(bibd[1, 1] < bibd[1, 2]),and([(bibd[1, 1] = bibd[1, 2]),or([(bibd[2, 1] < bibd[2, 2]),and([(bibd[2, 1] = bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> distribute_or_over_and ([("Base", 8400)]) 
and([or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),or([(bibd[1, 1] < bibd[1, 2]),or([(bibd[2, 1] < bibd[2, 2]),and([(bibd[2, 1] = bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
and([or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),or([(bibd[1, 1] < bibd[1, 2]),or([(bibd[2, 1] < bibd[2, 2]),and([(bibd[2, 1] = bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]),
(bibd[..,2] <=lex bibd[..,3]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),or([(bibd[2, 1] < bibd[2, 2]),and([(bibd[2, 1] = bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]);int(1..)]);int(1..)]);int(1..)]),
(bibd[..,2] <=lex bibd[..,3]) 

--

or([(bibd[1, 1] < bibd[1, 2]),or([(bibd[2, 1] < bibd[2, 2]),and([(bibd[2, 1] = bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> normalise_associative_commutative ([("Base", 8900)]) 
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),and([(bibd[2, 1] = bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]);int(1..)]);int(1..)]) 

--

or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),and([(bibd[2, 1] = bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> distribute_or_over_and ([("Base", 8400)]) 
and([or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]);int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
and([or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]);int(1..)]);int(1..)]),
(bibd[..,2] <=lex bibd[..,3]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]);int(1..)]),
(bibd[..,2] <=lex bibd[..,3]) 

--

or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),or([(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]);int(1..)]), 
   ~~> normalise_associative_commutative ([("Base", 8900)]) 
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]) 

--

(bibd[..,2] <=lex bibd[..,3]), 
   ~~> expand_lex_lt_leq ([("Smt", 2001)]) 
or([(bibd[1, 2] < bibd[1, 3]),and([(bibd[1, 2] = bibd[1, 3]),or([(bibd[2, 2] < bibd[2, 3]),and([(bibd[2, 2] = bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),and([(bibd[3, 2] = bibd[3, 3]),true;int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),and([(bibd[1, 2] = bibd[1, 3]),or([(bibd[2, 2] < bibd[2, 3]),and([(bibd[2, 2] = bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),and([(bibd[3, 2] = bibd[3, 3]),true;int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),and([(bibd[1, 2] = bibd[1, 3]),or([(bibd[2, 2] < bibd[2, 3]),and([(bibd[2, 2] = bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),and([(bibd[3, 2] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]) 

--

and([(bibd[3, 2] = bibd[3, 3]);int(1..)]), 
   ~~> remove_unit_vector_and ([("Base", 8800)]) 
(bibd[3, 2] = bibd[3, 3]) 

--

or([(bibd[1, 2] < bibd[1, 3]),and([(bibd[1, 2] = bibd[1, 3]),or([(bibd[2, 2] < bibd[2, 3]),and([(bibd[2, 2] = bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> distribute_or_over_and ([("Base", 8400)]) 
and([or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),or([(bibd[1, 2] < bibd[1, 3]),or([(bibd[2, 2] < bibd[2, 3]),and([(bibd[2, 2] = bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
and([or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),or([(bibd[1, 2] < bibd[1, 3]),or([(bibd[2, 2] < bibd[2, 3]),and([(bibd[2, 2] = bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),or([(bibd[2, 2] < bibd[2, 3]),and([(bibd[2, 2] = bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]) 

--

or([(bibd[1, 2] < bibd[1, 3]),or([(bibd[2, 2] < bibd[2, 3]),and([(bibd[2, 2] = bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> normalise_associative_commutative ([("Base", 8900)]) 
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),and([(bibd[2, 2] = bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]) 

--

or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),and([(bibd[2, 2] = bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> distribute_or_over_and ([("Base", 8400)]) 
and([or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]) 

--

and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
and([or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]);int(1..)]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
and([given block: int(1..3)

such that

(sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),]) = k)
 | block: int(1..3),]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]);int(1..)]) 

--

or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),or([(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]);int(1..)]), 
   ~~> normalise_associative_commutative ([("Base", 8900)]) 
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]) 

--

k, 
   ~~> substitute_value_lettings ([("Base", 5000)]) 
2 

--

Model before rewriting:

find object: int(1..3)
find __0: int(0..1)

such that

(0 != __0)

--

Final model:

find object: int(1..3)
find __0: int(0..1)

such that

(0 != __0)

Model before rewriting:

given object: int(1..3)

such that

bibd[object, block]

--

bibd[object, block], 
   ~~> index_to_bubble ([("Bubble", 6000)]) 
{bibd[object, block] @ and([__inDomain(object,int(1..3)),__inDomain(block,int(1..3));int(1..)])} 

--

{bibd[object, block] @ and([__inDomain(object,int(1..3)),__inDomain(block,int(1..3));int(1..)])}, 
   ~~> constant_evaluator ([("Constant", 9001)]) 
bibd[object, block] 

--

Final model:

given object: int(1..3)

such that

bibd[object, block]

sum([given object: int(1..3)

such that

bibd[object, block]
 | object: int(1..3),__0: int(0..1),]), 
   ~~> expand_comprehension_ac ([("Better_AC_Comprehension_Expansion", 2001)]) 
sum([bibd[1, block],bibd[2, block],bibd[3, block];int(1..)]) 

--

Model before rewriting:

find block: int(1..3)
find __0: bool

such that

(true != __0)

--

Final model:

find block: int(1..3)
find __0: bool

such that

(true != __0)

Model before rewriting:

given block: int(1..3)

such that

(sum([bibd[1, block],bibd[2, block],bibd[3, block];int(1..)]) = 2)

--

Final model:

given block: int(1..3)

such that

(sum([bibd[1, block],bibd[2, block],bibd[3, block];int(1..)]) = 2)

and([given block: int(1..3)

such that

(sum([bibd[1, block],bibd[2, block],bibd[3, block];int(1..)]) = 2)
 | block: int(1..3),__0: bool,]), 
   ~~> expand_comprehension_ac ([("Better_AC_Comprehension_Expansion", 2001)]) 
and([(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2);int(1..)]) 

--

and([(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2);int(1..)]),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = r)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]) 

--

r, 
   ~~> substitute_value_lettings ([("Base", 5000)]) 
UnsafeDiv(product([l,(v - 1);int(1..)]), (k - 1)) 

--

(v - 1), 
   ~~> minus_to_sum ([("Base", 8400)]) 
sum([v,-(1);int(1..)]) 

--

(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = UnsafeDiv(product([l,sum([v,-(1);int(1..)]);int(1..)]), (k - 1)))
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = UnsafeDiv(product([l,sum([v,-1;int(1..)]);int(1..)]), (k - 1)))
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]) 

--

(k - 1), 
   ~~> minus_to_sum ([("Base", 8400)]) 
sum([k,-(1);int(1..)]) 

--

(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = UnsafeDiv(product([l,sum([v,-1;int(1..)]);int(1..)]), sum([k,-(1);int(1..)])))
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = UnsafeDiv(product([l,sum([v,-1;int(1..)]);int(1..)]), sum([k,-1;int(1..)])))
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]) 

--

UnsafeDiv(product([l,sum([v,-1;int(1..)]);int(1..)]), sum([k,-1;int(1..)])), 
   ~~> div_to_bubble ([("Bubble", 6000)]) 
{SafeDiv(product([l,sum([v,-1;int(1..)]);int(1..)]), sum([k,-1;int(1..)])) @ (sum([k,-1;int(1..)]) != 0)} 

--

l, 
   ~~> substitute_value_lettings ([("Base", 5000)]) 
1 

--

product([1,sum([v,-1;int(1..)]);int(1..)]), 
   ~~> reorder_product ([("Base", 8800)]) 
product([sum([v,-1;int(1..)]);int(1..)]) 

--

product([sum([v,-1;int(1..)]);int(1..)]), 
   ~~> remove_unit_vector_products ([("Base", 8800)]) 
sum([v,-1;int(1..)]) 

--

v, 
   ~~> substitute_value_lettings ([("Base", 5000)]) 
3 

--

(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = {SafeDiv(sum([3,-1;int(1..)]), sum([k,-1;int(1..)])) @ (sum([k,-1;int(1..)]) != 0)})
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = {SafeDiv(2, sum([k,-1;int(1..)])) @ (sum([k,-1;int(1..)]) != 0)})
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]) 

--

k, 
   ~~> substitute_value_lettings ([("Base", 5000)]) 
2 

--

(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = {SafeDiv(2, sum([2,-1;int(1..)])) @ (sum([k,-1;int(1..)]) != 0)})
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = {2 @ (sum([k,-1;int(1..)]) != 0)})
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]) 

--

k, 
   ~~> substitute_value_lettings ([("Base", 5000)]) 
2 

--

(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = {2 @ (sum([2,-1;int(1..)]) != 0)})
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
and([given object: int(1..3)

such that

(sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),]) = 2)
 | object: int(1..3),]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]) 

--

Model before rewriting:

find block: int(1..3)
find __0: int(0..1)

such that

(0 != __0)

--

Final model:

find block: int(1..3)
find __0: int(0..1)

such that

(0 != __0)

Model before rewriting:

given block: int(1..3)

such that

bibd[object, block]

--

bibd[object, block], 
   ~~> index_to_bubble ([("Bubble", 6000)]) 
{bibd[object, block] @ and([__inDomain(object,int(1..3)),__inDomain(block,int(1..3));int(1..)])} 

--

{bibd[object, block] @ and([__inDomain(object,int(1..3)),__inDomain(block,int(1..3));int(1..)])}, 
   ~~> constant_evaluator ([("Constant", 9001)]) 
bibd[object, block] 

--

Final model:

given block: int(1..3)

such that

bibd[object, block]

sum([given block: int(1..3)

such that

bibd[object, block]
 | block: int(1..3),__0: int(0..1),]), 
   ~~> expand_comprehension_ac ([("Better_AC_Comprehension_Expansion", 2001)]) 
sum([bibd[object, 1],bibd[object, 2],bibd[object, 3];int(1..)]) 

--

Model before rewriting:

find object: int(1..3)
find __0: bool

such that

(true != __0)

--

Final model:

find object: int(1..3)
find __0: bool

such that

(true != __0)

Model before rewriting:

given object: int(1..3)

such that

(sum([bibd[object, 1],bibd[object, 2],bibd[object, 3];int(1..)]) = 2)

--

Final model:

given object: int(1..3)

such that

(sum([bibd[object, 1],bibd[object, 2],bibd[object, 3];int(1..)]) = 2)

and([given object: int(1..3)

such that

(sum([bibd[object, 1],bibd[object, 2],bibd[object, 3];int(1..)]) = 2)
 | object: int(1..3),__0: bool,]), 
   ~~> expand_comprehension_ac ([("Better_AC_Comprehension_Expansion", 2001)]) 
and([(sum([bibd[1, 1],bibd[1, 2],bibd[1, 3];int(1..)]) = 2),(sum([bibd[2, 1],bibd[2, 2],bibd[2, 3];int(1..)]) = 2),(sum([bibd[3, 1],bibd[3, 2],bibd[3, 3];int(1..)]) = 2);int(1..)]) 

--

(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
and([(sum([bibd[1, 1],bibd[1, 2],bibd[1, 3];int(1..)]) = 2),(sum([bibd[2, 1],bibd[2, 2],bibd[2, 3];int(1..)]) = 2),(sum([bibd[3, 1],bibd[3, 2],bibd[3, 3];int(1..)]) = 2);int(1..)]),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
(sum([bibd[1, 1],bibd[1, 2],bibd[1, 3];int(1..)]) = 2),
(sum([bibd[2, 1],bibd[2, 2],bibd[2, 3];int(1..)]) = 2),
(sum([bibd[3, 1],bibd[3, 2],bibd[3, 3];int(1..)]) = 2),
and([given object1: int(1..3)

such that

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),]) = l))
 | object2: int(1..3),])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]) 

--

l, 
   ~~> substitute_value_lettings ([("Base", 5000)]) 
1 

--

Model before rewriting:

find block: int(1..3)
find __0: int(0..1)
find __1: int(0..1)

such that

(0 != __1)

--

Final model:

find block: int(1..3)
find __0: int(0..1)
find __1: int(0..1)

such that

(0 != __1)

Model before rewriting:

given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])

--

bibd[object1, block], 
   ~~> index_to_bubble ([("Bubble", 6000)]) 
{bibd[object1, block] @ and([__inDomain(object1,int(1..3)),__inDomain(block,int(1..3));int(1..)])} 

--

product([{bibd[object1, block] @ and([__inDomain(object1,int(1..3)),__inDomain(block,int(1..3));int(1..)])},bibd[object2, block];int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
product([bibd[object1, block],bibd[object2, block];int(1..)]) 

--

bibd[object2, block], 
   ~~> index_to_bubble ([("Bubble", 6000)]) 
{bibd[object2, block] @ and([__inDomain(object2,int(1..3)),__inDomain(block,int(1..3));int(1..)])} 

--

product([bibd[object1, block],{bibd[object2, block] @ and([__inDomain(object2,int(1..3)),__inDomain(block,int(1..3));int(1..)])};int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
product([bibd[object1, block],bibd[object2, block];int(1..)]) 

--

Final model:

given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])

sum([given block: int(1..3)

such that

product([bibd[object1, block],bibd[object2, block];int(1..)])
 | block: int(1..3),__0: int(0..1),__1: int(0..1),]), 
   ~~> expand_comprehension_ac ([("Better_AC_Comprehension_Expansion", 2001)]) 
sum([product([bibd[object1, 1],bibd[object2, 1];int(1..)]),product([bibd[object1, 2],bibd[object2, 2];int(1..)]),product([bibd[object1, 3],bibd[object2, 3];int(1..)]);int(1..)]) 

--

Model before rewriting:

find object2: int(1..3)
find __0: bool
find __1: bool

such that

(true != (__0) -> (__1))

--

(__0) -> (__1), 
   ~~> introduce_reifyimply_ineq_from_imply ([("Minion", 4400)]) 
Ineq(__0, __1, 0) 

--

(true != Ineq(__0, __1, 0)), 
   ~~> flatten_generic ([("Minion", 4200)]) 
(true != __2) 
new variables:
  find __2: bool
new constraints:
  __2 =aux Ineq(__0, __1, 0)
--

__2 =aux Ineq(__0, __1, 0), 
   ~~> bool_eq_to_reify ([("Minion", 4400)]) 
Reify(Ineq(__0, __1, 0), __2) 

--

Final model:

find object2: int(1..3)
find __0: bool
find __1: bool
find __2: bool

such that

(true != __2),
Reify(Ineq(__0, __1, 0), __2)

Model before rewriting:

given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([product([bibd[object1, 1],bibd[object2, 1];int(1..)]),product([bibd[object1, 2],bibd[object2, 2];int(1..)]),product([bibd[object1, 3],bibd[object2, 3];int(1..)]);int(1..)]) = 1))

--

(object1 < object2), 
   ~~> lt_to_leq ([("Minion", 8400)]) 
(object1 <= sum([object2,-1;int(1..)])) 

--

(object1 <= sum([object2,-1;int(1..)])), 
   ~~> introduce_weighted_sumleq_sumgeq ([("Minion", 4600)]) 
SumGeq([-1, object2], object1) 

--

Final model:

given object2: int(1..3)

such that

(SumGeq([-1, object2], object1)) -> ((sum([product([bibd[object1, 1],bibd[object2, 1];int(1..)]),product([bibd[object1, 2],bibd[object2, 2];int(1..)]),product([bibd[object1, 3],bibd[object2, 3];int(1..)]);int(1..)]) = 1))

and([given object2: int(1..3)

such that

((object1 < object2)) -> ((sum([product([bibd[object1, 1],bibd[object2, 1];int(1..)]),product([bibd[object1, 2],bibd[object2, 2];int(1..)]),product([bibd[object1, 3],bibd[object2, 3];int(1..)]);int(1..)]) = 1))
 | object2: int(1..3),__0: bool,__1: bool,__2: bool,]), 
   ~~> expand_comprehension_ac ([("Better_AC_Comprehension_Expansion", 2001)]) 
and([(SumGeq([-1, 1], object1)) -> ((sum([product([bibd[object1, 1],bibd[1, 1];int(1..)]),product([bibd[object1, 2],bibd[1, 2];int(1..)]),product([bibd[object1, 3],bibd[1, 3];int(1..)]);int(1..)]) = 1)),(SumGeq([-1, 2], object1)) -> ((sum([product([bibd[object1, 1],bibd[2, 1];int(1..)]),product([bibd[object1, 2],bibd[2, 2];int(1..)]),product([bibd[object1, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1)),(SumGeq([-1, 3], object1)) -> ((sum([product([bibd[object1, 1],bibd[3, 1];int(1..)]),product([bibd[object1, 2],bibd[3, 2];int(1..)]),product([bibd[object1, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1));int(1..)]) 

--

(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
(sum([bibd[1, 1],bibd[1, 2],bibd[1, 3];int(1..)]) = 2),
(sum([bibd[2, 1],bibd[2, 2],bibd[2, 3];int(1..)]) = 2),
(sum([bibd[3, 1],bibd[3, 2],bibd[3, 3];int(1..)]) = 2),
and([given object1: int(1..3)

such that

and([(SumGeq([-1, 1], object1)) -> ((sum([product([bibd[object1, 1],bibd[1, 1];int(1..)]),product([bibd[object1, 2],bibd[1, 2];int(1..)]),product([bibd[object1, 3],bibd[1, 3];int(1..)]);int(1..)]) = 1)),(SumGeq([-1, 2], object1)) -> ((sum([product([bibd[object1, 1],bibd[2, 1];int(1..)]),product([bibd[object1, 2],bibd[2, 2];int(1..)]),product([bibd[object1, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1)),(SumGeq([-1, 3], object1)) -> ((sum([product([bibd[object1, 1],bibd[3, 1];int(1..)]),product([bibd[object1, 2],bibd[3, 2];int(1..)]),product([bibd[object1, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1));int(1..)])
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
(sum([bibd[1, 1],bibd[1, 2],bibd[1, 3];int(1..)]) = 2),
(sum([bibd[2, 1],bibd[2, 2],bibd[2, 3];int(1..)]) = 2),
(sum([bibd[3, 1],bibd[3, 2],bibd[3, 3];int(1..)]) = 2),
and([given object1: int(1..3)

such that

(SumGeq([-1, 1], object1)) -> ((sum([product([bibd[object1, 1],bibd[1, 1];int(1..)]),product([bibd[object1, 2],bibd[1, 2];int(1..)]),product([bibd[object1, 3],bibd[1, 3];int(1..)]);int(1..)]) = 1)),
(SumGeq([-1, 2], object1)) -> ((sum([product([bibd[object1, 1],bibd[2, 1];int(1..)]),product([bibd[object1, 2],bibd[2, 2];int(1..)]),product([bibd[object1, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1)),
(SumGeq([-1, 3], object1)) -> ((sum([product([bibd[object1, 1],bibd[3, 1];int(1..)]),product([bibd[object1, 2],bibd[3, 2];int(1..)]),product([bibd[object1, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1))
 | object1: int(1..3),]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]) 

--

Model before rewriting:

find object1: int(1..3)
find __0: bool
find __1: bool
find __2: bool

such that

(true != and([(SumGeq([-1, 1], object1)) -> (__0),(SumGeq([-1, 2], object1)) -> (__1),(SumGeq([-1, 3], object1)) -> (__2);int(1..)]))

--

(true != and([(SumGeq([-1, 1], object1)) -> (__0),(SumGeq([-1, 2], object1)) -> (__1),(SumGeq([-1, 3], object1)) -> (__2);int(1..)])), 
   ~~> flatten_generic ([("Minion", 4200)]) 
(true != __3) 
new variables:
  find __3: bool
new constraints:
  __3 =aux and([(SumGeq([-1, 1], object1)) -> (__0),(SumGeq([-1, 2], object1)) -> (__1),(SumGeq([-1, 3], object1)) -> (__2);int(1..)])
--

__3 =aux and([(SumGeq([-1, 1], object1)) -> (__0),(SumGeq([-1, 2], object1)) -> (__1),(SumGeq([-1, 3], object1)) -> (__2);int(1..)]), 
   ~~> bool_eq_to_reify ([("Minion", 4400)]) 
Reify(and([(SumGeq([-1, 1], object1)) -> (__0),(SumGeq([-1, 2], object1)) -> (__1),(SumGeq([-1, 3], object1)) -> (__2);int(1..)]), __3) 

--

(SumGeq([-1, 1], object1)) -> (__0), 
   ~~> flatten_imply ([("Minion", 4200)]) 
(__4) -> (__0) 
new variables:
  find __4: bool
new constraints:
  __4 =aux SumGeq([-1, 1], object1)
--

(__4) -> (__0), 
   ~~> introduce_reifyimply_ineq_from_imply ([("Minion", 4400)]) 
Ineq(__4, __0, 0) 

--

__4 =aux SumGeq([-1, 1], object1), 
   ~~> bool_eq_to_reify ([("Minion", 4400)]) 
Reify(SumGeq([-1, 1], object1), __4) 

--

(SumGeq([-1, 2], object1)) -> (__1), 
   ~~> flatten_imply ([("Minion", 4200)]) 
(__5) -> (__1) 
new variables:
  find __5: bool
new constraints:
  __5 =aux SumGeq([-1, 2], object1)
--

(__5) -> (__1), 
   ~~> introduce_reifyimply_ineq_from_imply ([("Minion", 4400)]) 
Ineq(__5, __1, 0) 

--

__5 =aux SumGeq([-1, 2], object1), 
   ~~> bool_eq_to_reify ([("Minion", 4400)]) 
Reify(SumGeq([-1, 2], object1), __5) 

--

(SumGeq([-1, 3], object1)) -> (__2), 
   ~~> flatten_imply ([("Minion", 4200)]) 
(__6) -> (__2) 
new variables:
  find __6: bool
new constraints:
  __6 =aux SumGeq([-1, 3], object1)
--

(__6) -> (__2), 
   ~~> introduce_reifyimply_ineq_from_imply ([("Minion", 4400)]) 
Ineq(__6, __2, 0) 

--

__6 =aux SumGeq([-1, 3], object1), 
   ~~> bool_eq_to_reify ([("Minion", 4400)]) 
Reify(SumGeq([-1, 3], object1), __6) 

--

Final model:

find object1: int(1..3)
find __0: bool
find __1: bool
find __2: bool
find __3: bool
find __4: bool
find __5: bool
find __6: bool

such that

(true != __3),
Reify(and([Ineq(__4, __0, 0),Ineq(__5, __1, 0),Ineq(__6, __2, 0);int(1..)]), __3),
Reify(SumGeq([-1, 1], object1), __4),
Reify(SumGeq([-1, 2], object1), __5),
Reify(SumGeq([-1, 3], object1), __6)

Model before rewriting:

given object1: int(1..3)

such that

(SumGeq([-1, 1], object1)) -> ((sum([product([bibd[object1, 1],bibd[1, 1];int(1..)]),product([bibd[object1, 2],bibd[1, 2];int(1..)]),product([bibd[object1, 3],bibd[1, 3];int(1..)]);int(1..)]) = 1)),
(SumGeq([-1, 2], object1)) -> ((sum([product([bibd[object1, 1],bibd[2, 1];int(1..)]),product([bibd[object1, 2],bibd[2, 2];int(1..)]),product([bibd[object1, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1)),
(SumGeq([-1, 3], object1)) -> ((sum([product([bibd[object1, 1],bibd[3, 1];int(1..)]),product([bibd[object1, 2],bibd[3, 2];int(1..)]),product([bibd[object1, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1))

--

Final model:

given object1: int(1..3)

such that

(SumGeq([-1, 1], object1)) -> ((sum([product([bibd[object1, 1],bibd[1, 1];int(1..)]),product([bibd[object1, 2],bibd[1, 2];int(1..)]),product([bibd[object1, 3],bibd[1, 3];int(1..)]);int(1..)]) = 1)),
(SumGeq([-1, 2], object1)) -> ((sum([product([bibd[object1, 1],bibd[2, 1];int(1..)]),product([bibd[object1, 2],bibd[2, 2];int(1..)]),product([bibd[object1, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1)),
(SumGeq([-1, 3], object1)) -> ((sum([product([bibd[object1, 1],bibd[3, 1];int(1..)]),product([bibd[object1, 2],bibd[3, 2];int(1..)]),product([bibd[object1, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1))

and([given object1: int(1..3)

such that

(SumGeq([-1, 1], object1)) -> ((sum([product([bibd[object1, 1],bibd[1, 1];int(1..)]),product([bibd[object1, 2],bibd[1, 2];int(1..)]),product([bibd[object1, 3],bibd[1, 3];int(1..)]);int(1..)]) = 1)),
(SumGeq([-1, 2], object1)) -> ((sum([product([bibd[object1, 1],bibd[2, 1];int(1..)]),product([bibd[object1, 2],bibd[2, 2];int(1..)]),product([bibd[object1, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1)),
(SumGeq([-1, 3], object1)) -> ((sum([product([bibd[object1, 1],bibd[3, 1];int(1..)]),product([bibd[object1, 2],bibd[3, 2];int(1..)]),product([bibd[object1, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1))
 | object1: int(1..3),__0: bool,__1: bool,__2: bool,__3: bool,__4: bool,__5: bool,__6: bool,]), 
   ~~> expand_comprehension_ac ([("Better_AC_Comprehension_Expansion", 2001)]) 
and([and([(SumGeq([-1, 1], 1)) -> ((sum([product([bibd[1, 1],bibd[1, 1];int(1..)]),product([bibd[1, 2],bibd[1, 2];int(1..)]),product([bibd[1, 3],bibd[1, 3];int(1..)]);int(1..)]) = 1)),(SumGeq([-1, 2], 1)) -> ((sum([product([bibd[1, 1],bibd[2, 1];int(1..)]),product([bibd[1, 2],bibd[2, 2];int(1..)]),product([bibd[1, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1)),(SumGeq([-1, 3], 1)) -> ((sum([product([bibd[1, 1],bibd[3, 1];int(1..)]),product([bibd[1, 2],bibd[3, 2];int(1..)]),product([bibd[1, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1));int(1..)]),and([(SumGeq([-1, 1], 2)) -> ((sum([product([bibd[2, 1],bibd[1, 1];int(1..)]),product([bibd[2, 2],bibd[1, 2];int(1..)]),product([bibd[2, 3],bibd[1, 3];int(1..)]);int(1..)]) = 1)),(SumGeq([-1, 2], 2)) -> ((sum([product([bibd[2, 1],bibd[2, 1];int(1..)]),product([bibd[2, 2],bibd[2, 2];int(1..)]),product([bibd[2, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1)),(SumGeq([-1, 3], 2)) -> ((sum([product([bibd[2, 1],bibd[3, 1];int(1..)]),product([bibd[2, 2],bibd[3, 2];int(1..)]),product([bibd[2, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1));int(1..)]);int(1..)]) 

--

(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
(sum([bibd[1, 1],bibd[1, 2],bibd[1, 3];int(1..)]) = 2),
(sum([bibd[2, 1],bibd[2, 2],bibd[2, 3];int(1..)]) = 2),
(sum([bibd[3, 1],bibd[3, 2],bibd[3, 3];int(1..)]) = 2),
and([and([(SumGeq([-1, 1], 1)) -> ((sum([product([bibd[1, 1],bibd[1, 1];int(1..)]),product([bibd[1, 2],bibd[1, 2];int(1..)]),product([bibd[1, 3],bibd[1, 3];int(1..)]);int(1..)]) = 1)),(SumGeq([-1, 2], 1)) -> ((sum([product([bibd[1, 1],bibd[2, 1];int(1..)]),product([bibd[1, 2],bibd[2, 2];int(1..)]),product([bibd[1, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1)),(SumGeq([-1, 3], 1)) -> ((sum([product([bibd[1, 1],bibd[3, 1];int(1..)]),product([bibd[1, 2],bibd[3, 2];int(1..)]),product([bibd[1, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1));int(1..)]),and([(SumGeq([-1, 1], 2)) -> ((sum([product([bibd[2, 1],bibd[1, 1];int(1..)]),product([bibd[2, 2],bibd[1, 2];int(1..)]),product([bibd[2, 3],bibd[1, 3];int(1..)]);int(1..)]) = 1)),(SumGeq([-1, 2], 2)) -> ((sum([product([bibd[2, 1],bibd[2, 1];int(1..)]),product([bibd[2, 2],bibd[2, 2];int(1..)]),product([bibd[2, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1)),(SumGeq([-1, 3], 2)) -> ((sum([product([bibd[2, 1],bibd[3, 1];int(1..)]),product([bibd[2, 2],bibd[3, 2];int(1..)]),product([bibd[2, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1));int(1..)]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
(sum([bibd[1, 1],bibd[1, 2],bibd[1, 3];int(1..)]) = 2),
(sum([bibd[2, 1],bibd[2, 2],bibd[2, 3];int(1..)]) = 2),
(sum([bibd[3, 1],bibd[3, 2],bibd[3, 3];int(1..)]) = 2),
and([(sum([product([bibd[1, 1],bibd[2, 1];int(1..)]),product([bibd[1, 2],bibd[2, 2];int(1..)]),product([bibd[1, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1),(sum([product([bibd[1, 1],bibd[3, 1];int(1..)]),product([bibd[1, 2],bibd[3, 2];int(1..)]),product([bibd[1, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1);int(1..)]),
and([(sum([product([bibd[2, 1],bibd[3, 1];int(1..)]),product([bibd[2, 2],bibd[3, 2];int(1..)]),product([bibd[2, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]) 

--

(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
(sum([bibd[1, 1],bibd[1, 2],bibd[1, 3];int(1..)]) = 2),
(sum([bibd[2, 1],bibd[2, 2],bibd[2, 3];int(1..)]) = 2),
(sum([bibd[3, 1],bibd[3, 2],bibd[3, 3];int(1..)]) = 2),
and([(sum([product([bibd[1, 1],bibd[2, 1];int(1..)]),product([bibd[1, 2],bibd[2, 2];int(1..)]),product([bibd[1, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1),(sum([product([bibd[1, 1],bibd[3, 1];int(1..)]),product([bibd[1, 2],bibd[3, 2];int(1..)]),product([bibd[1, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1);int(1..)]),
and([(sum([product([bibd[2, 1],bibd[3, 1];int(1..)]),product([bibd[2, 2],bibd[3, 2];int(1..)]),product([bibd[2, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
(sum([bibd[1, 1],bibd[1, 2],bibd[1, 3];int(1..)]) = 2),
(sum([bibd[2, 1],bibd[2, 2],bibd[2, 3];int(1..)]) = 2),
(sum([bibd[3, 1],bibd[3, 2],bibd[3, 3];int(1..)]) = 2),
(sum([product([bibd[1, 1],bibd[2, 1];int(1..)]),product([bibd[1, 2],bibd[2, 2];int(1..)]),product([bibd[1, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1),
(sum([product([bibd[1, 1],bibd[3, 1];int(1..)]),product([bibd[1, 2],bibd[3, 2];int(1..)]),product([bibd[1, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1),
(sum([product([bibd[2, 1],bibd[3, 1];int(1..)]),product([bibd[2, 2],bibd[3, 2];int(1..)]),product([bibd[2, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)]) 

--

Final model:

letting b be UnsafeDiv(product([product([l,v;int(1..)]),(v - 1);int(1..)]), product([k,(k - 1);int(1..)]))
find bibd: matrix indexed by [[int(1..3), int(1..3)]] of int(0..1)
letting k be 2
letting l be 1
letting r be UnsafeDiv(product([l,(v - 1);int(1..)]), (k - 1))
letting v be 3

such that

(sum([bibd[1, 1],bibd[2, 1],bibd[3, 1];int(1..)]) = 2),
(sum([bibd[1, 2],bibd[2, 2],bibd[3, 2];int(1..)]) = 2),
(sum([bibd[1, 3],bibd[2, 3],bibd[3, 3];int(1..)]) = 2),
(sum([bibd[1, 1],bibd[1, 2],bibd[1, 3];int(1..)]) = 2),
(sum([bibd[2, 1],bibd[2, 2],bibd[2, 3];int(1..)]) = 2),
(sum([bibd[3, 1],bibd[3, 2],bibd[3, 3];int(1..)]) = 2),
(sum([product([bibd[1, 1],bibd[2, 1];int(1..)]),product([bibd[1, 2],bibd[2, 2];int(1..)]),product([bibd[1, 3],bibd[2, 3];int(1..)]);int(1..)]) = 1),
(sum([product([bibd[1, 1],bibd[3, 1];int(1..)]),product([bibd[1, 2],bibd[3, 2];int(1..)]),product([bibd[1, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1),
(sum([product([bibd[2, 1],bibd[3, 1];int(1..)]),product([bibd[2, 2],bibd[3, 2];int(1..)]),product([bibd[2, 3],bibd[3, 3];int(1..)]);int(1..)]) = 1),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 1] = bibd[2, 1]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 2] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[2, 1]),(bibd[1, 2] < bibd[2, 2]),(bibd[1, 3] < bibd[2, 3]),(bibd[1, 3] = bibd[2, 3]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 1] = bibd[3, 1]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 2] = bibd[3, 2]);int(1..)]),
or([(bibd[2, 1] < bibd[3, 1]),(bibd[2, 2] < bibd[3, 2]),(bibd[2, 3] < bibd[3, 3]),(bibd[2, 3] = bibd[3, 3]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[1, 1] = bibd[1, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[2, 1] = bibd[2, 2]);int(1..)]),
or([(bibd[1, 1] < bibd[1, 2]),(bibd[2, 1] < bibd[2, 2]),(bibd[3, 1] < bibd[3, 2]),(bibd[3, 1] = bibd[3, 2]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[1, 2] = bibd[1, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[2, 2] = bibd[2, 3]);int(1..)]),
or([(bibd[1, 2] < bibd[1, 3]),(bibd[2, 2] < bibd[2, 3]),(bibd[3, 2] < bibd[3, 3]),(bibd[3, 2] = bibd[3, 3]);int(1..)])

