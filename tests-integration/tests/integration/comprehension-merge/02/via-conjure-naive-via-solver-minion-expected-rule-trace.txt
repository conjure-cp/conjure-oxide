Model before rewriting:

find x: int(0..5)

such that

and([ or([ ((i = j)) -> ((x = 0)) | j : int(1..2) ]) | i : int(1..2) ])

--

Model before rewriting:

quantified j: int(1..2)

--

, 
   ~~> eval_root ([("Constant", 9001)]) 
true 

--

Final model:

quantified j: int(1..2)

such that

true

Model before rewriting:

quantified j: int(1..2)

such that

((i = j)) -> ((x = 0))

--

Final model:

quantified j: int(1..2)

such that

((i = j)) -> ((x = 0))

[ ((i = j)) -> ((x = 0)) | j : int(1..2) ], 
   ~~> expand_comprehension_via_solver ([("Base", 2000)]) 
[((i = 1)) -> ((x = 0)),((i = 2)) -> ((x = 0));int(1..)] 

--

Model before rewriting:

quantified i: int(1..2)

--

, 
   ~~> eval_root ([("Constant", 9001)]) 
true 

--

Final model:

quantified i: int(1..2)

such that

true

Model before rewriting:

quantified i: int(1..2)

such that

or([((i = 1)) -> ((x = 0)),((i = 2)) -> ((x = 0));int(1..)])

--

Final model:

quantified i: int(1..2)

such that

or([((i = 1)) -> ((x = 0)),((i = 2)) -> ((x = 0));int(1..)])

[ or([((i = 1)) -> ((x = 0)),((i = 2)) -> ((x = 0));int(1..)]) | i : int(1..2) ], 
   ~~> expand_comprehension_via_solver ([("Base", 2000)]) 
[or([((1 = 1)) -> ((x = 0)),((1 = 2)) -> ((x = 0));int(1..)]),or([((2 = 1)) -> ((x = 0)),((2 = 2)) -> ((x = 0));int(1..)]);int(1..)] 

--

and([or([((1 = 1)) -> ((x = 0)),((1 = 2)) -> ((x = 0));int(1..)]),or([((2 = 1)) -> ((x = 0)),((2 = 2)) -> ((x = 0));int(1..)]);int(1..)]), 
   ~~> constant_evaluator ([("Constant", 9001)]) 
true 

--

Final model:

find x: int(0..5)

such that

true

