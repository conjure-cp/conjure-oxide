rd_("BdUse Z3 Bitvector theory for integers0Bn<strong>Supported by:</strong> JsonInput, SMT.000Bi<strong>Supported by:</strong> JsonInput.011AjContains the success value00000Ee<code>or(&lt;vec_expr&gt;)</code> <strong>Supported by:</strong> JsonInput, SAT, SMT.0AfThe id of this object.0Fb<code>|x|</code> - absolute value of <code>x</code> <strong>Supported by:</strong> JsonInput, SMT.0Ef<code>and(&lt;vec_expr&gt;)</code> <strong>Supported by:</strong> JsonInput, SAT, SMT.0AnGlobal command line arguments.AhContains the error value0000088Ec<code>iff(a, b)</code> a &lt;-&gt; b <strong>Supported by:</strong> JsonInput, SMT.0ChAn integer value in the given ranges (e.g. int(1, 3..5))0::CdUse Z3 Linear Integer Arithmetic theory for integers0Ea<code>max(&lt;vec_expr&gt;)</code> <strong>Supported by:</strong> JsonInput, SMT.0Ea<code>min(&lt;vec_expr&gt;)</code> <strong>Supported by:</strong> JsonInput, SMT.0CkA clone-on-write, reference counted pointer to an AST type.0DhNegation: <code>-x</code> <strong>Supported by:</strong> JsonInput, SMT.0??Dg<code>not(a)</code> <strong>Supported by:</strong> JsonInput, SAT, SMT.0CnA SolverAdaptor for interacting with the SatSolver generic \xe2\x80\xa6000BmA set of elements drawn from the inner domain000CeA SolverAdaptor for interacting with SMT solvers, \xe2\x80\xa6000Ea<code>sum(&lt;vec_expr&gt;)</code> <strong>Supported by:</strong> JsonInput, SMT.0BdRepresentation of a Minion Variable.CbTypes used for representing Minion models in Rust.CnTriggers a panic with a detailed bug report message, while \xe2\x80\xa60CkRepresents a reduction that also adds clauses to the model.0CiCreate a new int domain with the given ranges. If the \xe2\x80\xa60CcReturns the lower bound of the range, if it has one0BkCreates a new model from the given context.AjCreates a new declaration.BoCreate a new range with a lower and upper boundDnCreates a new [<code>Submodel</code>] as a child scope of <code>parent</code>.AnCreates an empty symbol table.BkConstructs a new <code>Moo&lt;T&gt;</code>.BmCreates an AbstractComprehensionBuilder with:CiConstructs a new adaptor using the given theories for \xe2\x80\xa657432160AnCreates an empty Minion model.CcCreates a new builder instance with the default \xe2\x80\xa6CmCreate a new set domain with the given element domain and \xe2\x80\xa60DkAn <code>Atom</code> is an indivisible expression, such as a literal or \xe2\x80\xa60AnA boolean value (true / false)0DbA reference to an object stored in the [<code>SymbolTable</code>].0AdThe top of the model0ChA rule with a name, application function, and rule sets.0ChTrait implemented by rules to transform parts of a tree.B`A name given in the input model.0CkCreate a new boolean domain and return a pointer to it. \xe2\x80\xa60AoReturns the argument unchanged.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CcReturns the upper bound of the range, if it has one0CcCreates a representation object for the given name.0BaCalls <code>U::from(self)</code>.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CnIf this range is bounded, returns a lazy iterator over all \xe2\x80\xa60CkIf the two ranges join, return a new range which spans both0BaGets the kind of the declaration.0BaGets the name of the declaration.AiThe name of the rule set.10CiRepresents a reduction with no side effects on the model.0B`The root node of this sub-model.0ClTraits and types representing a transformation rule to a \xe2\x80\xa6DcCreates a new <code>Name::User</code> from a <code>&amp;str</code>.0AoAn empty domain of a given type0BbAn unspecified error has occurred.0BgA type with an [<code>ObjectId</code>].0Bi<strong>Supported by:</strong> JsonInput.0ElEnsures that <code>a-&gt;b</code> (material implication). <strong>Supported by:</strong> \xe2\x80\xa60CgLexicographical &gt; between two matrices This is a \xe2\x80\xa60BjLexicographical &lt; between two matrices.0AkBinary subtraction operator0AaAn Essence model.00oA Minion model.AlA unique id, used to disting0A`Catch-all error.DmSet of codomain values function is defined for <strong>Supported </strong>\xe2\x80\xa60mSolve a modelCo<code>toInt(b)</code> casts boolean expression b to an integer.0BoA tuple of N elements, each with its own domain000<<C`Applies side-effects (e.g. symbol table updates)0CiApplies the rule to the given subtree and returns the \xe2\x80\xa6DhConsumes the builder and returns the constructed <code>Engine</code> \xe2\x80\xa6CjGet the i-th child of a node, or return a syntax error \xe2\x80\xa60CkRemoves all side-effects previously registered by the rule.ClCreate a new empty domain of the given type and return a \xe2\x80\xa60BhTop-level error types for Conjure-Oxide.0lError types.CkGet the named field of a node, or return a syntax error \xe2\x80\xa60CmReturns true if this interval overlaps or touches another \xe2\x80\xa60ChExhaustively rewrites a tree using user-defined rule \xe2\x80\xa6A`Essence parsers.CcFunctions to pretty print a model as a Minion file.AmCreates a <code>Range</code>.0BmSerde serialization/ deserialization helpers.0CfShell type for which to generate the completion scriptBcRuns the solver on the given model.0Aoconjure_oxide solve sub-commandAeExecution statistics.0CmCreate a new tuple domain with the given element domains. \xe2\x80\xa60BgCompute the intersection of two domainsCkConvenience method to take Domain::union of the Domains \xe2\x80\xa6010BfDirectly encode matrices as SMT Arrays0CgDecompose arrays into auxiliary variables using the \xe2\x80\xa60ClThis term does not have a category in isolation - e.g. a \xe2\x80\xa60ClAn expression representing \xe2\x80\x9cA is valid as long as B is \xe2\x80\xa60CfAn engine for exhaustively transforming trees with \xe2\x80\xa6AgA fully resolved domain0ChLexicographical &gt;= between two matrices This is a \xe2\x80\xa60BjLexicographical &lt;= between two matrices0ClAn N-dimensional matrix of elements drawn from the inner \xe2\x80\xa6CjA n-dimensional matrix with a value domain and n-index \xe2\x80\xa6CbA 1 dimensional matrix slice with an index domain.210BlA SolverAdaptor for interacting with Minion.000hA record000BnThe function type used in a <code>Rule</code>.0DcA uniform type for <code>fn</code> pointers and closures, which \xe2\x80\xa6ClThis expression is for encoding ints for the SAT solver, \xe2\x80\xa60CcAn abstract representation of a constraints solver.0Bi<strong>Supported by:</strong> JsonInput.000ChRepresents the effects of a successful rule application.BkIf this domain is GroundDomain::Int or [\xe2\x80\xa60CmIf this is a set domain, get its attributes and a pointer \xe2\x80\xa60CfThis declaration as a decision variable, if it is one.0ClCreates a new declaration pointer with the same contents \xe2\x80\xa60CbGets the domain of the declaration, if it has one.CjLooks up the domain of name if it has one and is in scope.01CdPerform gradual rule-based transformations on trees.CiExtends the symbol table with the given symbol table, \xe2\x80\xa60CmCreates a new variable in this symbol table with a unique \xe2\x80\xa60BlInserts a declaration into the symbol table.0BmTrue if this is a GroundDomain::Int or an \xe2\x80\xa60BnIf the domain is ground, return its size boundAoGets the length of this domain.10CnLooks up the declaration with the given name, checking all \xe2\x80\xa60DjCreates a new matrix <code>AbstractLiteral</code> optionally with some \xe2\x80\xa6BlUtility functions for working with matrices.ClCreate a new matrix domain with the given element domain \xe2\x80\xa6210BeSave solutions to the given JSON fileBmFunctions for pretty printing Conjure models.0ClCreate a new tuple domain with the given entries. If the \xe2\x80\xa60CjA high-level API for interacting with constraints solvers.0AdSolver family to useB`States of a <code>Solver</code>.0AhThe status of the search0CkIf the domain is ground, return an iterator over its values0E`<code>allDiff(&lt;vec_expr&gt;)</code> <strong>Supported by:</strong> JsonInput.0B`All subcommands of conjure-oxideDoSet of domain values function is defined for <strong>Supported by:</strong> \xe2\x80\xa60EgFlatten matrix operator <code>flatten(M)</code> or <code>flatten(n, M)</code> where \xe2\x80\xa60Bi<strong>Supported by:</strong> JsonInput.0CdA literal value, equivalent to constants in Conjure.0BbA name generated by Conjure-Oxide.0Dk<code>a * b * c * ...</code> <strong>Supported by:</strong> JsonInput, SMT.0ChA structure representing a set of rules with a name, \xe2\x80\xa60CnDivision after preventing division by zero, usually with a \xe2\x80\xa60ChModulo after preventing mod 0, usually with a bubble \xe2\x80\xa60Ce<code>UnsafePow</code> after preventing undefinedness0oAn unknown type0CaAn iterator that traverses the syntax tree in \xe2\x80\xa60CkAn iterator that traverses the syntax tree in pre-order \xe2\x80\xa60BoCannot construct this from outside this module.000CkCreates a new search variable and adds it to the symbol \xe2\x80\xa6BbThe cnf clauses in this sub-model.0CfFlattens a multi-dimensional matrix literal into a \xe2\x80\xa60CcVarious selector functions for different use cases.BbTrue if this is GroundDomain::Bool0BgChecks whether this expression is safe.0ChCreates a new decision variable declaration with the \xe2\x80\xa60C`Re-exported functions and types for convenience.ClIf this domain is ground, return a Moo to the underlying \xe2\x80\xa60CnMerge all joining ranges in the list, and return a new vec \xe2\x80\xa60CcThe symbol table for this sub-model as a reference.0mLog verboselymPrint versionCmThe callback function used to capture results from Minion \xe2\x80\xa6DdThe <em>category</em> of a term describes the kind of symbols it \xe2\x80\xa60ClA queue of commands (side-effects) to be applied after a \xe2\x80\xa6CfThe search was complete (i.e. the solver found all \xe2\x80\xa60BiThis term contains constants and lettings0BdRepresentation of a Minion constant.BeThis term contains decision variables0Cd<code>ineq(x,y,k)</code> ensures that x &lt;= y + k.0BbA function with a domain and rangeBmA function with attributes, domain, and range10Bi<strong>Supported by:</strong> JsonInput.0Eh<code>inDomain(x,domain)</code> iff <code>x</code> is in the domain <code>domain</code>.01111CmHolds a rule and its priority, along with the rule set it \xe2\x80\xa60CgA sub-model, representing a lexical scope in the model.03333AnGuaranteed to always typecheck0A`Solver adaptors.0BhAdds a single rule in a group by itself.CjIf this is a tuple domain, get pointers to its element \xe2\x80\xa60CmCommands encode side-effects that will take place after a \xe2\x80\xa6D`Returns true if <code>lit</code> is a valid value of this domain0AlCreate a new function domain0ChGets the name of the solver adaptor for pretty printing.0ChParse the given source code into a syntax tree using \xe2\x80\xa60BoReturns the identity element of this operation.0CkReturns true if this interval is strictly after another one0CjMakes a mutable reference into the given <code>Moo</code>.0CfUpdates the global metadata in-place via a mutable \xe2\x80\xa6ClReturns true if this interval overlaps another one, i.e. \xe2\x80\xa60DeA convenience macro to cast a list of <code>fn</code> pointers or \xe2\x80\xa60CmGiven a slice of ranges, create a single range that spans \xe2\x80\xa60CgGiven assignments for its representation variables, \xe2\x80\xa60CeRepresents a reduction that also adds a top-level \xe2\x80\xa60CeEnsures that x=|y| i.e. x is the absolute value of y.0CbLow-level minion constraint. See Expression::LexLt0BfTypes that have a <code>Domain</code>.0CkThe theory to use when encoding CO integers through the \xe2\x80\xa60Bi<strong>Supported by:</strong> JsonInput.0BcEnsures that <code>x**y = z</code>.0BfThis term contains parameters / givens0CmRepresents the result of applying a rule to an expression \xe2\x80\xa60AoA reference to a domain lettingChA reference to a declaration (variable, parameter, etc.)10AdA safe matrix index.0BmA safe matrix slice: <code>a[indices]</code>.0ClTests whether the Essence model is solvable with Conjure \xe2\x80\xa6ClDivision with a possibly undefined value (division by 0) \xe2\x80\xa60DmModulo with a possibly undefined value (mod 0) <strong>Supported </strong>\xe2\x80\xa60CbUnsafe power<code>x**y</code> (possibly undefined)0BcRepresentation of variable domains.CnReturns the domain that is the result of applying a binary \xe2\x80\xa60CkIf this domain is already ground, return a reference to \xe2\x80\xa60CkIf this is a matrix domain, get pointers to its element \xe2\x80\xa60CiIf this is a record domain, clone and return its entries.0EcMakes a clone of <code>self</code> into a <code>Representation</code> trait object.0CbGets the <code>Domain</code> of <code>self</code>.ClReturns the possible values of the expression, recursing \xe2\x80\xa610CnBuild a list of rules to apply (sorted by priority) from a \xe2\x80\xa6CmGet the rules of this rule set, evaluating them lazily if \xe2\x80\xa610BnCompute the intersection of two ground domainsBkCalculates the intersection of two domains.CmConvenience method to take Domain::intersect of the Domain\xe2\x80\xa60210BlIterates over symbol table entries in scope.0ClReturns true if this interval is strictly before another \xe2\x80\xa60BeReturns true if the domain is finite.CkWhether the range is <strong>finite</strong>. See also: \xe2\x80\xa610B`Creates a new given declaration.0Bgunique between objects of the same type0CjCreate a new UnresolvedDomain::Reference domain from a \xe2\x80\xa60BeThe rule name for this representaion.0CmRuns the solver on the given model, allowing modification \xe2\x80\xa60CbRegisters a pure transformation of the whole tree.Bna unique identifier of the type of this object0BcA type with a <code>Category</code>0CcGenerate a completion script for the shell providedBaAll supported Minion constraints.ClRepresents different types of expressions used to define \xe2\x80\xa60CcLow-level minion constraint. See Expression::LexLeq0AnEnsures that sum(vec) &gt;= x.0AnEnsures that sum(vec) &lt;= x.0ClThe search was incomplete (i.e. it was terminated before \xe2\x80\xa60CgThis term contains quantified variables / induction \xe2\x80\xa60DhA uniform type for selector functions such as <code>select_first</code>.CiA model that is de/serializable using <code>serde</code>.0BeA domain which may contain references0AbAdds a cnf clause.0CgAdds a new symbol to the symbol table (Wrapper over \xe2\x80\xa60ClIf this is an int domain, get a mutable reference to its \xe2\x80\xa60CiIf this is a set domain, get mutable reference to its \xe2\x80\xa60CmThis declaration as a mutable decision variable, if it is \xe2\x80\xa60BcCreates a <code>Domain::Int</code>.0CiGet the solver family that this solver adaptor belongs to0BdInitialises the model for rewriting.0AfThe input Essence file00ChCreate a new ground integer domain with the given ranges0CmThis crate provides low level Rust bindings to the Minion \xe2\x80\xa6DbPretty prints a <code>Vec&lt;T&gt;</code> in a vector like syntax.0AnRun Minion on the given Model.jtree-morphDjGiven an assignment for <code>self</code>, creates assignments for its \xe2\x80\xa60CkReturns a list of all possible values in an integer domain.0BmEnsures that <code>alldiff([a,b,...])</code>.0BlEnsures that x =-y, where x and y are atoms.0CjWraps all error types returned by <code>minion-sys</code>.Ed<code>reify(constraint,r)</code> ensures that r=1 iff <code>constraint</code> is \xe2\x80\xa60CkAddition over a pair of expressions (i.e. a + b) rather \xe2\x80\xa60CnA named field inside a record type. e.g. A, B in record{A: \xe2\x80\xa600CnAn auxiliary variable which is part of a Representation of \xe2\x80\xa60BeErrors returned by Solver on failure.0CcThe global symbol table, mapping names to their \xe2\x80\xa60CjStores all named variables in a Minion model alongside \xe2\x80\xa6oA matrix index.0BhA matrix slice: <code>a[indices]</code>.0CnCreates a new auxiliary variable and adds it to the symbol \xe2\x80\xa6AaAdds cnf clauses.0CnIf this is a function domain, get its (attributes, domain, \xe2\x80\xa60C`Returns this model as a [<code>Submodel</code>].0BiGets the <code>Category</code> of a term.0CfThe cnf clauses in this sub-model as a mutable vector.0BlThe top-level constraints in this sub-model.0CmParses a sequence of Essence expressions into a vector of \xe2\x80\xa60CiFor a Root expression, extends the inner vec with the \xe2\x80\xa60BdGets the domain of a named variable.EaCreates a new matrix <code>AbstractLiteral</code> from some <code>Vec</code>, \xe2\x80\xa60DgCreates a new matrix as an <code>Expression</code>, optionally with \xe2\x80\xa60CjGet the i-th named child of a node, or return a syntax \xe2\x80\xa60CjThe new subtree to be inserted as a result of applying \xe2\x80\xa6CmLooks up the return type for name if it has one and is in \xe2\x80\xa6CiGives the return type of the operator, and the return \xe2\x80\xa610CkThe symbol table for this sub-model as a mutable reference.0DdIf the expression is a list, returns a <em>copied</em> vector of \xe2\x80\xa6CgIf the AbstractLiteral is a list, returns its elements.10CdCreates an empty symbol table with the given parent.0Dh<code>fromSolution(name)</code> - Used in dominance relation definitions0CkThe theory to use when encoding CO integers through the \xe2\x80\xa60Eg<code>w-inset(x, [v1, v2, \xe2\x80\xa6 ])</code> ensures that the value of <code>x</code> is \xe2\x80\xa60CeRepresents errors that can occur during the model \xe2\x80\xa60CeAn error has occurred during the execution of Minion.BiErrors thrown by Minion during execution.CgReturned from SolverAdaptor when solving is successful.0CkA collection of theories to use for encoding various CO \xe2\x80\xa60AnAn unknown error has occurred.ClRegister an event handler to be called after moving $dir \xe2\x80\xa6ClIf this is [GroundDomain::Empty(ty)], get a reference to \xe2\x80\xa60CmIf this is a tuple domain, get a mutable reference to its \xe2\x80\xa60C`Parse Essence using conjure\xe2\x80\x99s ast-json output.CgParses an Essence expression into its corresponding \xe2\x80\xa60DdCreates an [<code>Domain::Int</code>] containing the given integers.0BeGet all meta-variable names in a node0BmReturns a new Context and Solver for solving.CbConverts the expression to a literal, if possible.0CnWhether the range is <strong>unbounded</strong> on both sides.0CgLooks up the declaration with the given name in the \xe2\x80\xa60ClReturns the number of possible elements indexable by the \xe2\x80\xa60CiParse an Essence variable domain into its Conjure AST \xe2\x80\xa60CkChanges the name in this declaration, returning the old \xe2\x80\xa60DhReplaces the root node with <code>new_root</code>, returning the old \xe2\x80\xa60DdReturns the first available <code>Update</code> if there is one, \xe2\x80\xa6CkPanics when called by the engine, printing the original \xe2\x80\xa6CmSets the selector function to be used when multiple rules \xe2\x80\xa6CkRetrieve a contiguous slice containing all the elements \xe2\x80\xa6ClReturns true if this interval touches another one on the \xe2\x80\xa60CkRepresents a reduction that also modifies the symbol table.0A`A comprehension.000CiA type that can be created with default values and an id.0BkAn error thrown by an operation on domains.0DgA builder type for constructing and configuring <code>Engine</code> \xe2\x80\xa6AcEnsures that x*y=z.0BjAn iterator over the variants of IntTheory0CkA ModelModifier provides an interface to modify a model \xe2\x80\xa60DcA <code>ModelModifier</code> for a solver that does not support \xe2\x80\xa60EbDe/Serialize an <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> as the id of the inner \xe2\x80\xa60CnRepresents the statistical data collected during the model \xe2\x80\xa60CiA common interface for calling underlying solver APIs \xe2\x80\xa60CmRegister an event handler to be called before moving $dir \xe2\x80\xa6CjSee crate::ast::comprehension::ComprehensionBuilder::guard0BdGets symbols added by this reduction0CnCreates a new Expression of this AC operator kind with the \xe2\x80\xa60CfIf this domain is already ground, return a mutable \xe2\x80\xa60ClIf this is a [GroundDomain::Int(rngs)], get an immutable \xe2\x80\xa60CmIf this is a matrix domain, get mutable references to its \xe2\x80\xa60CnIf this is a record domain, get a mutable reference to its \xe2\x80\xa60ClIf this is a GroundDomain::Set, get immutable references \xe2\x80\xa60CkIf this domain is unresolved, return a reference to the \xe2\x80\xa60CmSimplify an expression to a constant if possible Returns: \xe2\x80\xa600DfReturns a copied <code>Vec</code> of all rules registered with the \xe2\x80\xa60CeGets the representation rule named <code>name</code>.0BlGets the index domains for a matrix literal.0ChIf all the elements are literals, returns this as an \xe2\x80\xa60AfDo not run the solver.ChRegister a rule with the given rule sets and priorities.CmThis procedural macro registers a decorated function with \xe2\x80\xa61DkRewrites a <code>Model</code> by applying rule sets using an optimized, \xe2\x80\xa60CjA naive, exhaustive rewriter for development purposes. \xe2\x80\xa60CgSelects a random <code>Update</code> from the iterator.BdThe solver family used for this run.0ClSolver time as measured by the solver itself This may be \xe2\x80\xa60ClReturns true if this interval touches another one on the \xe2\x80\xa60CkUpdates or adds a declaration in the immediate local scope.0AoThe variable being represented.0CfThe possible kinds of associative-commutative (AC) \xe2\x80\xa60BeDeclaration of an auxiliary variable.0BoA shared pointer to a <code>Declaration</code>.00CiThe input model uses Minion features that are not yet \xe2\x80\xa6CjThe desired operation is not supported for this solver \xe2\x80\xa60CiEncodes the two-way relationship between a non-atomic \xe2\x80\xa60ChThe type for user-defined callbacks for use with Solver.0ClRegister an event handler to be called after moving $dir \xe2\x80\xa6AlAdds a top-level constraint.0CbAdds a collection of rules with the same priority.DgA builder type for constructing and configuring <code>Engine</code> \xe2\x80\xa6CiGets a given value from Minion\xe2\x80\x99s TableOut (where it \xe2\x80\xa6CbSave execution info as JSON to the given filepath.B`Modifying a model during search.0B`Get the named children of a node0DmPretty prints a <code>Vec&lt;CnfClause&gt;</code> as a list of clauses as \xe2\x80\xa60CfGet all top-level nodes that match the given predicate0ClLooks up the domain of name, resolving domain references \xe2\x80\xa60AlRuns the selected subcommandBeThe solver adaptor used for this run.0BhStop the solver after the given timeout.AoA specific kind of declaration.00BeThe model given to Minion is invalid.CjMultiplication over a pair of expressions (i.e. a * b) \xe2\x80\xa60AoPrint the JSON info file schemaClRegister an event handler to be called after moving $dir \xe2\x80\xa6CmRegister an event handler to be called before moving $dir \xe2\x80\xa6AkAdds top-level constraints.0CnIf this is a function domain, convert it to unresolved and \xe2\x80\xa60ChReturns this model as a mutable [<code>Submodel</code>].0CnIf this is a GroundDomain::Tuple, get immutable references \xe2\x80\xa60BfGets symbols changed by this reduction0ClThe top-level constraints in this sub-model as a mutable \xe2\x80\xa60DjCreates a new default value of type <code>T</code>, but with the given \xe2\x80\xa60DeReturns <code>Expression</code>s representing each representation \xe2\x80\xa60AiExtra rule sets to enableCeIterates over entries in the local symbol table only.0DiReplaces the cnf clauses with <code>new_clauses</code>, returning the \xe2\x80\xa60CgGets the domain of the declaration and fully resolve it0CfIf we have the only reference to T then unwrap it. \xe2\x80\xa60CiRepresents a decision variable within a computational \xe2\x80\xa60CjCollection of static elements that are gathered into a \xe2\x80\xa6DeThe state returned by <code>Solver</code> if solving has not been \xe2\x80\xa60DaThe state returned by <code>Solver</code> if solving has been \xe2\x80\xa60BmAn iterator over the variants of MatrixTheory0Ed<code>element_one(vec, i, e)</code> specifies that <code>vec[i] = e</code>. This \xe2\x80\xa60Ek<code>reifyimply(constraint,r)</code> ensures that <code>r-&gt;constraint</code>, where \xe2\x80\xa60CnThe desired operation is supported by this solver adaptor, \xe2\x80\xa60EjDe/Serialize an <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> as its inner value <code>T</code>.0BmAn iterator over the variants of SolverFamily0CmRegister an event handler to be called before moving $dir \xe2\x80\xa6CgIf this is [GroundDomain::Empty(ty)], get a mutable \xe2\x80\xa60CdIf this is a GroundDomain::Matrix, get immutable \xe2\x80\xa60CnIf this is a GroundDomain::Record, get a mutable reference \xe2\x80\xa60CbThis declaration as a value letting, if it is one.0CnHelper function for tests to compare the actual diagnostic \xe2\x80\xa60ClCreates declarations for the representation variables of \xe2\x80\xa60C`Construct a ground domain from a slice of valuesClFor a vector of literals, creates a domain that contains \xe2\x80\xa610CjGet the dependencies of this rule set, evaluating them \xe2\x80\xa60ClGet a rule by name. Returns the rule with the given name \xe2\x80\xa60BnOutput file for the human readable rule trace.DdCreates a new matrix as an <code>Expression</code> from a (Rust) \xe2\x80\xa60BgCreates a new record field declaration.0CnDo not use better comprehension expanding for ac operators \xe2\x80\xa6CdParse an Essence expression into its Conjure AST \xe2\x80\xa60DiReplaces the model contents with <code>new_submodel</code>, returning \xe2\x80\xa60CmRecursively sorts the keys of all JSON objects within the \xe2\x80\xa6ClThe result of applying a rule to an expression. Contains \xe2\x80\xa60CfDefines dominance (\xe2\x80\x9cSolution A is preferred over \xe2\x80\xa60CcThis declaration as a domain letting, if it is one.0ClIf this is a [GroundDomain::Int(rngs)], get an immutable \xe2\x80\xa60CmIf this is a GroundDomain::Set, get mutable references to \xe2\x80\xa60ClIf this domain is unresolved, return a mutable reference \xe2\x80\xa60BjCreates a [<code>GroundDomain::Int</code>]0CmFor some index domains, returns a list containing each of \xe2\x80\xa60CgFlattens a multi-dimensional matrix literal into an \xe2\x80\xa60CaThe scope for variables in generator expressions.000DhGet all rule sets Returns a <code>Vec</code> of static references to \xe2\x80\xa60DkSearches recursively in <code>../tests/integration</code> folder for an \xe2\x80\xa60CgGet rules grouped by priority from a list of rule sets.0CfTrue iff self and other are both atomic and identical.0BkTrue if the expression is a matrix literal.0BhCreates a new value letting declaration.0oHelper function0Bjconjure-oxide print-info-schema subcommandCnRegister a rule set with the given name, dependencies, and \xe2\x80\xa6CnThis procedural macro registers a rule set with the global \xe2\x80\xa61CiResolves the final set of rule sets to apply based on \xe2\x80\xa60CnLooks up the return type for name if has one and is in the \xe2\x80\xa60DaSelects an <code>Update</code> based on user input through stdin.BmUse the native parser instead of Conjure\xe2\x80\x99s.CgGet the dependencies of this rule set, including itself0CiCreates a comprehension with the given return expression.0DdWrites a complete Minion file for this model to <code>writer</code>.Cg(De)serializes a <code>DeclarationPtr</code> as its id.0Df(De)serializes a <code>DeclarationPtr</code> as the declaration it \xe2\x80\xa60Dj<code>w-literal(x,k)</code> ensures that x == k, where x is a variable \xe2\x80\xa60Dl<code>weightedsumgeq(cs,xs,total)</code> ensures that cs.xs &gt;= total, \xe2\x80\xa60Dl<code>weightedsumleq(cs,xs,total)</code> ensures that cs.xs &lt;= total, \xe2\x80\xa60ClA variable divided into several auxiliary ones through a \xe2\x80\xa60CeAdds a collection of rule groups to the existing one.ChIf this is a GroundDomain::Function, get its (attrs, \xe2\x80\xa60CnChecks if the conjure executable is present in PATH and if \xe2\x80\xa6DjGets the representation <code>representation</code> for <code>name</code>.0BmGets the canonical ordering of all variables.CbTrue iff expr only references induction variables.0BiCreates a new domain letting declaration.0CgCreates a new decision variable with the quantified \xe2\x80\xa60ChThe root node of this sub-model, as a mutable reference.0CcThe requested modification to the model has failed.0CkAdds a guard to the comprehension. Returns false if the \xe2\x80\xa60CnIf this is a GroundDomain::Tuple, get mutable reference to \xe2\x80\xa60CiGiven some guard and tail expressions, constructs the \xe2\x80\xa60CfNumber of solutions to return. 0 returns all solutionsDiReplaces the top-level constraints with <code>new_constraints</code>, \xe2\x80\xa60CkGets all initialised representations for <code>name</code>.0BoThe symbol table used in the return expression.000CmWrites the minion solutions to a generated JSON file, and \xe2\x80\xa6CnSort the \xe2\x80\x9cvariables\xe2\x80\x9d field by name. We have to do this \xe2\x80\xa6CnIf this expression is an associative-commutative operator, \xe2\x80\xa60CfReturns the categories of all sub-expressions of self.0AnA builder for a comprehension.0C`Ensures that floor(x/y)=z. Always true when y=0.0Dj<code>w-inintervalset(x, [a1,a2, b1,b2, \xe2\x80\xa6 ])</code> ensures that the \xe2\x80\xa60CmIf this is a GroundDomain::Matrix, get mutable references \xe2\x80\xa60CnIf this is a GroundDomain::Record, get a mutable reference \xe2\x80\xa60CjThis declaration as a mutable value letting, if it is one.0CnExit after all comprehensions have been unrolled, printing \xe2\x80\xa6CiGet a rule set by name. Returns the rule set with the \xe2\x80\xa60CjCreates a new given declaration backed by a quantified \xe2\x80\xa60CeGets the parent of this symbol table as a mutable \xe2\x80\xa60CjParse a find statement into a map of decision variable \xe2\x80\xa60EaThis is the same as <code>m[x]</code> except when <code>m</code> is of the forms:0EaWrites the <code>SEARCH</code> section of the Minion file to <code>writer</code>.BcHigher-level abstract comprehension0CkThis declaration as a mutable domain letting, if it is one.0CaThe symbol table for the comprehension generators0CjHelper function to see all the error nodes tree-sitter \xe2\x80\xa60BlReads a human-readable rule trace text file.CaThe symbol table for this sub-model as a pointer.0CdIf this is a GroundDomain::Function, get mutable \xe2\x80\xa60CmDetects very simple semantic issues in source and returns \xe2\x80\xa60CmA macro to document enum variants by the things that they \xe2\x80\xa6CiConverts the constraints in this submodel to a single \xe2\x80\xa60EeCreates a matrix with elements <code>elems</code>, with domain <code>int(1..)</code>.0DgReads only the first <code>max_lines</code> from a serialised model \xe2\x80\xa6AmSave a solver input file to .CjUse the experimental optimized / dirty-clean rewriter, \xe2\x80\xa6BiEnsures that x%y=z. Always true when y=0.0CkDetects syntactic issues in the essence source text and \xe2\x80\xa60CkParse a letting statement into a SymbolTable containing \xe2\x80\xa60ChThe symbol table for the comprehension return expression0DfSelects the <code>Update</code> which results in the smallest subtree.CmIf the expression is a matrix, gets it elements and index \xe2\x80\xa60BoWrites a solver input file to the given writer.000EdWrites the <code>VARIABLES</code> section of the Minion file to <code>writer</code>.CeCreates a new expression generator with the given \xe2\x80\xa60CnAdds the solver adaptor name and family (if they exist) to \xe2\x80\xa60CkCollects all ObjId values from the model using uniplate \xe2\x80\xa60DjSearches for an <code>.essence</code> file at the given filepath, then \xe2\x80\xa60EgGets the representation <code>representation</code> for <code>name</code>, creating \xe2\x80\xa60ChGets the canonical ordering of search variables (i.e \xe2\x80\xa6DkWhether the range is <strong>bounded</strong> on either side. A bounded \xe2\x80\xa60ClParse an Essence file into a Model using the tree-sitter \xe2\x80\xa6000CiThe symbol table for this sub-model as a mutable pointer.0EhWrites the <code>CONSTRAINTS</code> section of the Minion file to <code>writer</code>\xe2\x80\xa6ChWall time as measured by Conjure-Oxide (not the solver).0DlWrites the variable declaration of <code>name</code> to <code>writer</code>.CnPretty prints, in essence syntax, the variable declaration \xe2\x80\xa60DhSee <code>enumerate_indices</code>. This function zips the two given \xe2\x80\xa60BiPrints the schema for the JSON info file.CkCheck for multiple equally applicable rules, exiting if \xe2\x80\xa6DkGet all rule sets for a given solver family. Returns a <code>Vec</code> \xe2\x80\xa60E`Pretty prints a <code>Vec&lt;Expression&gt;</code> as if it were a top level \xe2\x80\xa60CmPretty prints, in essence syntax, the declaration for the \xe2\x80\xa60ChLimit how many lines of the rewrite serialisation we \xe2\x80\xa611DfPretty prints a <code>Vec&lt;Expression&gt;</code> as if it were a \xe2\x80\xa60CnDo not check for multiple equally applicable rules [default\xe2\x80\xa6CjA macro to document enum variants with the things that \xe2\x80\xa6ClTrue if the expression is an associative and commutative \xe2\x80\xa60CaThe rewriter to use for rewriting comprehensions.0")