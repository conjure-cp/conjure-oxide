//! The symbol table.
//!
//! See the item documentation for [`SymbolTable`] for more details.
use std::collections::BTreeSet;
use std::fmt::Display;
use std::{cell::RefCell, collections::BTreeMap};

use itertools::izip;
use serde::{Deserialize, Serialize};
use serde_with::serde_as;
use uniplate::derive::Uniplate;
use uniplate::Tree;
use uniplate::{Biplate, Uniplate};

use crate::ast::variables::DecisionVariable;

use super::{Domain, Expression, ReturnType};
use derivative::Derivative;

/// A reference to an object stored in the [`SymbolTable`].
#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Name {
    /// A name given in the input model.
    UserName(String),
    /// A name generated by Conjure-Oxide.
    MachineName(i32),
}

uniplate::derive_unplateable!(Name);

impl Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Name::UserName(s) => write!(f, "{}", s),
            Name::MachineName(i) => write!(f, "__{}", i),
        }
    }
}

/// The global symbol table, mapping names to their definitions.
///
/// Names in the symbol table are unique, including between different types of object stored in the
/// symbol table. For example, you cannot have a letting and decision variable with the same name.
///
/// # Symbol Kinds
///
/// The symbol table tracks the following types of symbol:
///
/// ## Decision Variables
///
/// ```text
/// find NAME: DOMAIN
/// ```
///
/// See [`DecisionVariable`](super::DecisionVariable).
///
/// ## Lettings
///
/// Lettings define constants, of which there are two types:
///
///   + **Constant values**: `letting val be A`, where A is an [`Expression`].
///
///     A can be any integer, boolean, or matrix expression.
///     A can include references to other lettings, model parameters, and, unlike Savile Row,
///     decision variables.
///
///   + **Constant domains**: `letting Domain be domain D`, where D is a [`Domain`].
///
///     D can include references to other lettings and model parameters, and, unlike Savile Row,
///     decision variables.
///
/// Unless otherwise stated, these follow the semantics specified in section 2.2.2 of the Savile
/// Row manual (version 1.9.1 at time of writing).
#[derive(Derivative)]
#[derivative(PartialEq)]
#[serde_as]
#[derive(Clone, Debug, Eq, Serialize, Deserialize)]
pub struct SymbolTable {
    #[serde_as(as = "Vec<(_, _)>")]
    table: BTreeMap<Name, SymbolKind>,

    #[derivative(Hash = "ignore")]
    #[derivative(PartialEq = "ignore")]
    next_machine_name: RefCell<i32>,
}

#[non_exhaustive]
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, Uniplate)]
enum SymbolKind {
    DecisionVariable(DecisionVariable),
    ValueLetting(Expression),
    DomainLetting(Domain),
}

impl SymbolTable {
    /// Creates an empty symbol table.
    pub fn new() -> Self {
        SymbolTable {
            table: BTreeMap::new(),
            next_machine_name: RefCell::new(0),
        }
    }

    /*****************************/
    /*        get entries        */
    /*****************************/

    /// Returns an iterator over the names in the symbol table.
    ///
    /// Alias of [`names`](SymbolTable::names).
    pub fn keys(&self) -> impl Iterator<Item = &Name> {
        self.names()
    }

    /// Returns an iterator over the names in the symbol table.
    pub fn names(&self) -> impl Iterator<Item = &Name> {
        self.table.keys()
    }

    /// Returns an iterator over the names and definitions of all decision variables in the symbol
    /// table.
    pub fn iter_var(&self) -> impl Iterator<Item = (&Name, &DecisionVariable)> {
        self.table.iter().filter_map(|(n, s)| {
            if let SymbolKind::DecisionVariable(var) = s {
                Some((n, var))
            } else {
                None
            }
        })
    }

    /// Returns a reference to the decision variable with the given name.
    ///
    /// Returns `None` if:
    ///
    /// + There is no decision variable with that name.
    ///
    /// + The decision variable with that name has been deleted.
    ///
    /// + The object with that name is not a decision variable.
    pub fn get_var(&self, name: &Name) -> Option<&DecisionVariable> {
        if let Some(SymbolKind::DecisionVariable(var)) = self.table.get(name) {
            Some(var)
        } else {
            None
        }
    }

    /// Returns a mutable reference to the decision variable with the given name.
    ///
    /// Returns `None` if:
    ///
    /// + There is no decision variable with that name.
    ///
    /// + The decision variable with that name has been deleted.
    ///
    /// + The object with that name is not a decision variable.
    pub fn get_var_mut(&mut self, name: &Name) -> Option<&mut DecisionVariable> {
        if let Some(SymbolKind::DecisionVariable(var)) = self.table.get_mut(name) {
            Some(var)
        } else {
            None
        }
    }

    /// Returns an iterator over the names and definitions of all values lettings in the symbol
    /// table.
    pub fn iter_value_letting(&self) -> impl Iterator<Item = (&Name, &Expression)> {
        self.table.iter().filter_map(|(n, s)| {
            if let SymbolKind::ValueLetting(var) = s {
                Some((n, var))
            } else {
                None
            }
        })
    }

    /// Returns a mutable iterator over the names and definitions of all values lettings in the
    /// symbol table.
    pub fn iter_value_letting_mut(&mut self) -> impl Iterator<Item = (&Name, &mut Expression)> {
        self.table.iter_mut().filter_map(|(n, s)| {
            if let SymbolKind::ValueLetting(var) = s {
                Some((n, var))
            } else {
                None
            }
        })
    }

    /// Returns a reference to the value letting with the given name.
    ///
    /// Returns `None` if:
    ///
    /// + There is no value letting with that name.
    ///
    /// + The object with that name is not a value letting.
    pub fn get_value_letting(&self, name: &Name) -> Option<&Expression> {
        if let Some(SymbolKind::ValueLetting(var)) = self.table.get(name) {
            Some(var)
        } else {
            None
        }
    }

    /// Returns a mutable reference to the value letting with the given name.
    ///
    /// Returns `None` if:
    ///
    /// + There is no value letting with that name.
    ///
    /// + The object with that name is not a value letting.
    pub fn get_value_letting_mut(&mut self, name: &Name) -> Option<&mut Expression> {
        if let Some(SymbolKind::ValueLetting(var)) = self.table.get_mut(name) {
            Some(var)
        } else {
            None
        }
    }

    /// Returns an iterator over the names and definitions of all domain lettings in the symbol
    /// table.
    pub fn iter_domain_letting(&self) -> impl Iterator<Item = (&Name, &Domain)> {
        self.table.iter().filter_map(|(n, s)| {
            if let SymbolKind::DomainLetting(domain) = s {
                Some((n, domain))
            } else {
                None
            }
        })
    }

    /// Returns a reference to the domain letting with the given name.
    ///
    /// Returns `None` if:
    ///
    /// + There is no domain letting with that name.
    ///
    /// + The object with that name is not a domain letting.
    pub fn get_domain_letting(&self, name: &Name) -> Option<&Domain> {
        if let Some(SymbolKind::DomainLetting(domain)) = self.table.get(name) {
            Some(domain)
        } else {
            None
        }
    }

    /// Returns a mutable reference to the domain letting with the given name.
    ///
    /// Returns `None` if:
    ///
    /// + There is no domain letting with that name.
    ///
    /// + The object with that name is not a domain letting.
    pub fn get_domain_letting_mut(&mut self, name: &Name) -> Option<&mut Domain> {
        if let Some(SymbolKind::DomainLetting(domain)) = self.table.get_mut(name) {
            Some(domain)
        } else {
            None
        }
    }
    /********************************/
    /*        mutate entries        */
    /********************************/

    /// Adds a decision variable to the symbol table as `name`.
    ///
    /// Returns `None` if there is a decision variable or other object with that name in the symbol
    /// table.
    pub fn add_var(&mut self, name: Name, var: DecisionVariable) -> Option<()> {
        if let std::collections::btree_map::Entry::Vacant(e) = self.table.entry(name) {
            e.insert(SymbolKind::DecisionVariable(var));
            Some(())
        } else {
            None
        }
    }

    /// Updates a decision variable to the symbol table as `name`, or adds it.
    ///
    /// Returns `None` if `name` refers to an object that is not a decision variable.
    pub fn update_add_var(&mut self, name: Name, var: DecisionVariable) -> Option<()> {
        self.table.insert(name, SymbolKind::DecisionVariable(var));
        Some(())
    }

    /// Adds a value letting to the symbol table as `name`.
    ///
    /// Returns `None` if there is a value letting or other object with that name in the symbol
    /// table.
    pub fn add_value_letting(&mut self, name: Name, value: Expression) -> Option<()> {
        if let std::collections::btree_map::Entry::Vacant(e) = self.table.entry(name) {
            e.insert(SymbolKind::ValueLetting(value));
            Some(())
        } else {
            None
        }
    }

    /// Updates a value letting to the symbol table as `name`, or adds it.
    ///
    /// Returns `None` if `name` refers to an object that is not a value letting.
    pub fn update_add_value_letting(&mut self, name: Name, value: Expression) -> Option<()> {
        self.table.insert(name, SymbolKind::ValueLetting(value));
        Some(())
    }

    /// Adds a domain letting to the symbol table as `name`.
    ///
    /// Returns `None` if there is a domain letting or other object with that name in the symbol
    /// table.
    pub fn add_domain_letting(&mut self, name: Name, domain: Domain) -> Option<()> {
        if let std::collections::btree_map::Entry::Vacant(e) = self.table.entry(name) {
            e.insert(SymbolKind::DomainLetting(domain));
            Some(())
        } else {
            None
        }
    }

    /// Updates a domain letting to the symbol table as `name`, or adds it.
    ///
    /// Returns `None` if `name` refers to an object that is not a domain letting.
    pub fn update_add_domain_letting(&mut self, name: Name, domain: Domain) -> Option<()> {
        self.table.insert(name, SymbolKind::DomainLetting(domain));
        Some(())
    }

    /// Extends the symbol table with the given symbol table, updating the gensym counter if
    /// necessary.
    pub fn extend(&mut self, other: SymbolTable) {
        if other.names().count() > self.names().count() {
            let new_vars = other.names().collect::<BTreeSet<_>>();
            let old_vars = self.names().collect::<BTreeSet<_>>();

            for added_var in new_vars.difference(&old_vars) {
                let mut next_var = self.next_machine_name.borrow_mut();
                match *added_var {
                    Name::UserName(_) => {}
                    Name::MachineName(m) => {
                        if *m >= *next_var {
                            *next_var = *m + 1;
                        }
                    }
                }
            }
        }
        self.table.extend(other.table);
    }

    /****************************************/
    /*        get info about symbols        */
    /****************************************/

    /// Gets the domain of `name` if it exists and has a domain.
    pub fn domain_of(&self, name: &Name) -> Option<&Domain> {
        match self.table.get(name)? {
            SymbolKind::DecisionVariable(var) => Some(&var.domain),
            SymbolKind::ValueLetting(_) => None,
            SymbolKind::DomainLetting(domain) => Some(domain),
        }
    }

    /// Gets the domain of `name` as a mutable reference if it exists and has a domain.
    pub fn domain_of_mut(&mut self, name: &Name) -> Option<&mut Domain> {
        match self.table.get_mut(name)? {
            SymbolKind::DecisionVariable(var) => Some(&mut var.domain),
            SymbolKind::ValueLetting(_) => None,
            SymbolKind::DomainLetting(domain) => Some(domain),
        }
    }

    /// Gets the type of `name` if it exists and has a type.
    pub fn type_of(&self, name: &Name) -> Option<ReturnType> {
        match self.table.get(name)? {
            SymbolKind::DecisionVariable(var) => match var.domain {
                Domain::BoolDomain => Some(ReturnType::Bool),
                Domain::IntDomain(_) => Some(ReturnType::Int),
                Domain::DomainReference(ref n) => self.type_of(n),
            },
            SymbolKind::ValueLetting(expr) => expr.return_type(),
            SymbolKind::DomainLetting(domain) => match domain {
                Domain::BoolDomain => Some(ReturnType::Bool),
                Domain::IntDomain(_) => Some(ReturnType::Int),
                Domain::DomainReference(ref n) => self.type_of(n),
            },
        }
    }

    /// Returns an arbitrary variable name that is not in the symbol table.
    pub fn gensym(&self) -> Name {
        let num = *self.next_machine_name.borrow();
        *(self.next_machine_name.borrow_mut()) += 1;
        Name::MachineName(num) // incremented when inserted
    }
}

// At time of writing (03/02/2025), the derive macro doesn't like maps or the RefCell.
//
// Eventually, we will be able to ignore the refcell field, and derive instances for the map, but
// for now, here we use a manual implementation.
impl Uniplate for SymbolTable {
    fn uniplate(&self) -> (Tree<Self>, Box<dyn Fn(Tree<Self>) -> Self>) {
        // no recursion
        let self2 = self.clone();
        (Tree::Zero, Box::new(move |_| self2.clone()))
    }
}

impl Biplate<Expression> for SymbolTable {
    fn biplate(&self) -> (Tree<Expression>, Box<dyn Fn(Tree<Expression>) -> Self>) {
        let tree = Tree::Many(
            self.iter_value_letting()
                .map(|(_, expr)| Tree::One(expr.clone()))
                .collect(),
        );

        let self2 = self.clone();
        let ctx = Box::new(move |tree| {
            let Tree::Many(exprs) = tree else {
                panic!("unexpected children structure");
            };

            let mut self3 = self2.clone();
            for ((_, expr), new_expr) in izip!(self3.iter_value_letting_mut(), exprs.into_iter()) {
                let Tree::One(new_expr) = new_expr else {
                    panic!("unexpected children structure");
                };

                *expr = new_expr;
            }

            self3
        });

        (tree, ctx)
    }
}

impl Default for SymbolTable {
    fn default() -> Self {
        Self::new()
    }
}
