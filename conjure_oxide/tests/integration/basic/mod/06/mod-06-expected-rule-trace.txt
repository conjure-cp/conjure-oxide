
Model before rewriting:

find a: int(0..3)
find b: int(0..3)
find c: int(0..3)

such that

Not((a = b % c))

--

Successful Tranformation: 
b % c, 
~~> mod_to_bubble [6000; Bubble]
{SafeMod(b,c) @ (c != 0)}


--

Successful Tranformation: 
(a = {SafeMod(b,c) @ (c != 0)}), 
~~> bubble_up [8900; Bubble]
{(a = SafeMod(b,c)) @ and([(c != 0);int(1..)])}


--

Successful Tranformation: 
{(a = SafeMod(b,c)) @ and([(c != 0);int(1..)])}, 
~~> expand_bubble [8900; Bubble]
and([(a = SafeMod(b,c)),and([(c != 0);int(1..)]);int(1..)])


--

Successful Tranformation: 
and([(c != 0);int(1..)]), 
~~> remove_unit_vector_and [8800; Base]
(c != 0)


--

Successful Tranformation: 
Not(and([(a = SafeMod(b,c)),(c != 0);int(1..)])), 
~~> distribute_not_over_and [8400; Base]
or([Not((a = SafeMod(b,c))),Not((c != 0));int(1..)])


--

Successful Tranformation: 
Not((a = SafeMod(b,c))), 
~~> negated_eq_to_neq [8800; Base]
(a != SafeMod(b,c))


--

Successful Tranformation: 
Not((c != 0)), 
~~> negated_neq_to_eq [8800; Base]
(c = 0)


--

Successful Tranformation: 
(a != SafeMod(b,c)), 
~~> flatten_generic [4200; Minion]
(a != __0)
new variables:
  find __0: int(0..2)
new constraints:
  __0 =aux SafeMod(b,c)

--

Successful Tranformation: 
__0 =aux SafeMod(b,c), 
~~> introduce_modeq [4200; Minion]
ModEq(b, c, __0)


--


Final model:

find a: int(0..3)
find b: int(0..3)
find c: int(0..3)
find __0: int(0..2)

such that

or([(a != __0),(c = 0);int(1..)]),
ModEq(b, c, __0)

