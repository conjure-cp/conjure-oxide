
Model before rewriting:

letting A be false
letting NotA be Not(Not(Not(A)))
find b: int(1..20)

such that

(NotA) -> ((b < 3))

--

Successful Tranformation: 
(b < 3), 
~~> lt_to_leq [8400; Minion]
(b <= Sum([3,-1;int(1..)]))  
--

Successful Tranformation: 
Sum([3,-1;int(1..)]), 
~~> constant_evaluator [9001; Constant]
2  
--

Successful Tranformation: 
NotA, 
~~> substitute_value_lettings [5000; Base]
Not(Not(Not(A)))  
--

Successful Tranformation: 
Not(Not(Not(A))), 
~~> remove_double_negation [8400; Base]
Not(A)  
--

Successful Tranformation: 
A, 
~~> substitute_value_lettings [5000; Base]
false  
--

Successful Tranformation: 
Not(false), 
~~> constant_evaluator [9001; Constant]
true  
--

Successful Tranformation: 
(true) -> ((b <= 2)), 
~~> partial_evaluator [9000; Base]
(b <= 2)  
--

Successful Tranformation: 
(b <= 2), 
~~> leq_to_ineq [4100; Minion]
Ineq(b, 2, 0)  
--


Final model:

letting A be false
letting NotA be Not(Not(Not(A)))
find b: int(1..20)

such that

Ineq(b, 2, 0)

